<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>跟我一起学NDK-C++必知必会part1</title>
    <link href="/2021/07/26/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%AD%A6NDK-C++%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9Apart1/"/>
    <url>/2021/07/26/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%AD%A6NDK-C++%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9Apart1/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>NDK 采用 C/C++ 语言进行开发，所以学习 NDK 开发之前我们先来补充下必要的 C/C++ 知识。C++ 是对 C 语言的升级，C++ 程序设计语言可以归结为 C 程序设计语言的语法 + 面向对象程序设计，因此本课程只介绍 C++ 程序设计语言。相信 Android 应用层开发的同学对于 Java 语言能够得心应手，本课程对于 C++ 程序设计语言的不少知识会用 Java 类推</p><h3 id="基准语法"><a href="#基准语法" class="headerlink" title="基准语法"></a>基准语法</h3><ul><li>注释，和 Java 一致</li></ul><p>单行</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>  我是单行注释<br></code></pre></td></tr></table></figure><p>多行</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 我是多行注释</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><ul><li><p>语句之间用 ; 分隔，和 Java 一致</p></li><li><p>代码块包含在 {} 内，和 Java 一致</p></li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><table><thead><tr><th>类型</th><th>关键字</th><th>大小</th></tr></thead><tbody><tr><td>布尔型</td><td>bool</td><td>1个字节</td></tr><tr><td>字符型</td><td>char</td><td>1个字节</td></tr><tr><td>整型</td><td>int</td><td>4个字节</td></tr><tr><td>浮点型</td><td>float</td><td>4个字节</td></tr><tr><td>双浮点型</td><td>double</td><td>8个字节</td></tr><tr><td>无类型</td><td>void</td><td>/</td></tr><tr><td>宽字符型</td><td>wchar_t</td><td>2字节</td></tr></tbody></table><p>sizeof() 函数可以获取各数据类型所占字节数</p><h4 id="类型修饰符"><a href="#类型修饰符" class="headerlink" title="类型修饰符"></a>类型修饰符</h4><p>一些基本类型可以使用一个或多个类型修饰符进行修饰，修饰符修饰会改变所占内存大小</p><ul><li>signed</li><li>unsigned</li><li>short</li><li>long</li></ul><table><thead><tr><th>类型</th><th>大小</th><th>范围</th></tr></thead><tbody><tr><td>unsigned char</td><td>1个字节</td><td>0 到 255</td></tr><tr><td>signed char</td><td>1个字节</td><td>-128 到 127</td></tr><tr><td>unsigned int</td><td>4个字节</td><td>0 到 4294967295</td></tr><tr><td>signed int</td><td>4个字节</td><td>-2147483648 到 2147483647</td></tr><tr><td>short int</td><td>2个字节</td><td>-32768 到 32767</td></tr><tr><td>long int</td><td>8个字节</td><td>-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td></tr><tr><td>long double</td><td>16个字节</td><td>+/- 1.7e +/- 308 (~15 个数字)</td></tr></tbody></table><h4 id="定义新类型"><a href="#定义新类型" class="headerlink" title="定义新类型"></a>定义新类型</h4><p>关键字：typedef</p><p>语法：typedef type newname;</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">typedef int feet<span class="hljs-comment">;</span><br>feet age<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>定义了新类型 feet，使用和 int 一致</p><p>其实 wchar_t 类型是这样来的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">short</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">wchar_t</span><br></code></pre></td></tr></table></figure><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>语法：数据类型 变量名1，变量名2;</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> age; <span class="hljs-comment">// 只定义</span><br><span class="hljs-built_in">int</span> diatance = <span class="hljs-number">1200</span>; <span class="hljs-comment">// 定义并赋值</span><br></code></pre></td></tr></table></figure><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>语法：const 数据类型 常量名 = 常量值;</p><p>常量名一般用大写，运行时无法改变其数值，<font color=#FF8C00>如果申明时并未设置初始值，那么之后无法再设置数值</font></p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">const</span> <span class="hljs-built_in">float</span> <span class="hljs-literal">PI</span> = <span class="hljs-number">3.1415</span>;<br></code></pre></td></tr></table></figure><p>也可以使用<a href="#%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4" title="标题">宏定义</a>的方式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> PI 3.1415</span><br></code></pre></td></tr></table></figure><h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><p>包括赋值运算、算术运算、比较运算、逻辑运算、递增递减运算以及位运算，这些运算都和 Java 一致</p><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><h4 id="自动转换"><a href="#自动转换" class="headerlink" title="自动转换"></a>自动转换</h4><p>数值范围大的作为优先转换的对象，转换顺序如下：</p><blockquote><p>double &lt;- float &lt;- unsigned long &lt;-  long &lt;- unsigned int &lt;- int</p></blockquote><h4 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h4><p>语法：(强制转换类型名称) 表达式或变量;</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-built_in">int</span> a, b, <span class="hljs-keyword">avg</span>;<br><span class="hljs-keyword">avg</span> = (float)(a + b) / <span class="hljs-number">2</span>;<span class="hljs-comment">//将 a+b 的值转换为浮点数再除以 2</span><br></code></pre></td></tr></table></figure><h4 id="转型运算符"><a href="#转型运算符" class="headerlink" title="转型运算符"></a>转型运算符</h4><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>static_cast</td><td>转换数据类型</td></tr><tr><td>const_cast</td><td>转换指针或引用的常数类型</td></tr><tr><td>dynamic_cast</td><td>转换类继承体系中的对象指针或引用</td></tr><tr><td>reinterpret_cast</td><td>转换无关联的数据类型</td></tr></tbody></table><p>如下，用 static_cast 将变量 two 从 double 类型转换为 int 类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">int</span> one = <span class="hljs-number">9</span>;<br><span class="hljs-keyword">double</span> two = <span class="hljs-number">7.6</span>;<br>one = one + <span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">int</span>&gt;(two);<br></code></pre></td></tr></table></figure><h3 id="流程控制结构"><a href="#流程控制结构" class="headerlink" title="流程控制结构"></a>流程控制结构</h3><p>包括顺序结构、选择结构(if else)、循环结构(for、while/do while)，都和 Java 一致</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="数组定义"><a href="#数组定义" class="headerlink" title="数组定义"></a>数组定义</h4><p>语法：数据类型 数组名[数组大小]; 或 数据类型 数组名[] = {值1,值2,…};</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs inform7">int score<span class="hljs-comment">[3]</span>;<br>score<span class="hljs-comment">[0]</span> = 69;<br>score<span class="hljs-comment">[1]</span> = 71;<br>score<span class="hljs-comment">[2]</span> = 88;<br>或<br>int scores<span class="hljs-comment">[3]</span> = &#123;69, 71, 88&#125;;<br></code></pre></td></tr></table></figure><h4 id="数组赋值取值"><a href="#数组赋值取值" class="headerlink" title="数组赋值取值"></a>数组赋值取值</h4><p>语法：数组名[下标] = 值;</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">scores</span>[<span class="hljs-number">0</span>] = <span class="hljs-number">89</span>;<br></code></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="数组形式"><a href="#数组形式" class="headerlink" title="数组形式"></a>数组形式</h4><p>语法：char 字符串变量[] = “初始字符串”;</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">char</span> <span class="hljs-type">name</span>[] = &quot;Jone&quot;;<br></code></pre></td></tr></table></figure><h4 id="String-类"><a href="#String-类" class="headerlink" title="String 类"></a>String 类</h4><p>语法：string 字符串变量 = “初始字符串”;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;string&gt;</span> <span class="hljs-comment">//包含字符串头文件</span></span><br>string name = <span class="hljs-string">&quot;Jone&quot;</span>;<br></code></pre></td></tr></table></figure><p>String 类成员函数:</p><table><thead><tr><th>运算符</th><th>功能</th><th>用法</th></tr></thead><tbody><tr><td>append()</td><td>串接字符串</td><td>str.append(str2)</td></tr><tr><td>assign()</td><td>字符串赋值</td><td>str.assign(str2)</td></tr><tr><td>compare()</td><td>比较两个字符串</td><td>str.compare(str2)</td></tr><tr><td>replace()</td><td>替换字符串</td><td>str.replace(开始位置,长度,str2)</td></tr><tr><td>insert()</td><td>插入字符串</td><td>str.insert(开始位置,str2)</td></tr><tr><td>erase()</td><td>清除字符串的部分内容</td><td>str.erase(开始位置,清除字符数)</td></tr><tr><td>length()</td><td>获取字符串的长度</td><td>str.length();</td></tr><tr><td>size()</td><td>获取字符串大小</td><td>str.size();</td></tr><tr><td>find()</td><td>寻找字符串</td><td>str.find(str2);</td></tr><tr><td>substr()</td><td>获取字符串的部分子串</td><td>str.substr(开始位置,长度);</td></tr><tr><td>empty()</td><td>判断是否为空字符串</td><td>str.empty();</td></tr><tr><td>at()</td><td>获取指定位置字符</td><td>str.at(n);//n为第n个字符</td></tr></tbody></table><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>语法：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs abnf">返回数据类型 函数名(参数 = 默认值)&#123;<br>程序语句块<span class="hljs-comment">;</span><br>return 返回值<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b = <span class="hljs-number">3</span>)</span></span>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure><p><font color=#FF8C00>有默认值的参数务必放置在参数行的尾端</font></p><p><font color=#FF8C00>C++ 从上往下编译程序代码，如果在前面调用了后定义的函数，则必须在调用前加声明</font></p><h3 id="预处理指令"><a href="#预处理指令" class="headerlink" title="预处理指令"></a>预处理指令</h3><p>C++ 程序在开始进行编译前会先进行一项预处理操作，将程序中那些以 # 符号开头的预处理指令进行特别的处理。预处理指令不会翻译为机器码，只在编译之前起作用。因为预处理指令不是 C++ 语句，所以并不需要以分号 “;” 结束</p><ul><li>#define 宏定义指令<br>#define 是一种替换指令，可以用来定义宏名称，并且替换程序中的数值、字符串、程序语句或者函数</li></ul><p>语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> 宏名称 常数值</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> 宏名称 <span class="hljs-meta-string">&quot;字符串&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> 宏名称 程序语句</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> 宏名称 函数名称</span><br></code></pre></td></tr></table></figure><p>宏函数是一种可以传递参数来替换简单函数功能的宏，参数不需要指定类型</p><p>语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> 宏函数名称(参数行) 函数表达式</span><br></code></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#define <span class="hljs-constructor">RESULT(<span class="hljs-params">r1</span>, <span class="hljs-params">r2</span>, <span class="hljs-params">h</span>)</span> (r1+r2)*h/<span class="hljs-number">2.0</span><br></code></pre></td></tr></table></figure><p>如果想要取消 #define 所声明的宏时，只要使用下面的语法声明即可。取消之后不可以再使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">undef</span> 宏名称</span><br></code></pre></td></tr></table></figure><p>标准预处理宏</p><table><thead><tr><th>宏名称</th><th>说明</th></tr></thead><tbody><tr><td><strong>LINE</strong></td><td>正在编译的行在源文件的行号</td></tr><tr><td><strong>FILE</strong></td><td>被编译的源文件的文件名</td></tr><tr><td><strong>DATE</strong></td><td>存储编译开始的日期</td></tr><tr><td><strong>TIME</strong></td><td>存储编译开始的时间</td></tr></tbody></table><ul><li>#include 指令</li></ul><p>#include 指令也是一种宏命令，可以将指定的<a href="#%E5%A4%B4%E6%96%87%E4%BB%B6">头文件</a>包含到源文件中(类似于 Java 的 import)，实际上是用头文件中的声明替换，有两种指定方式</p><ol><li>#include &lt;文件名&gt;<br>编译程序将到默认的系统目录中查找指定的头文件，一般为系统头文件</li></ol><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br></code></pre></td></tr></table></figure><ol start="2"><li>#inclide “”<br>编译程序将到当前程序文件的工作目录中查找指定的头文件，一般为自定义头文件</li></ol><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;people/&quot;</span></span><br></code></pre></td></tr></table></figure><ul><li>条件编译指令</li></ul><p>有几个指令可以用来有选择地对部分程序源代码进行编译，这个过程被称为条件编译。条件预处理器的结构与 if 选择结构很像。共有六种：#if、#else、#elif、#endif、#ifdef、#ifndef</p><p>#if 指令类似于 if 条件语句，#else 指令类似于 else 条件语句，#elif 类似于 else if 条件语句，#endif 条件编译结束标识</p><p>语法如下：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta">#if 条件语句</span><br>程序块<span class="hljs-number">1</span><br><span class="hljs-meta">#elif 条件语句</span><br>程序块<span class="hljs-number">2</span><br><span class="hljs-meta">#else</span><br>程序块<span class="hljs-number">3</span><br><span class="hljs-meta">#endif</span><br></code></pre></td></tr></table></figure><p>#ifdef 如果定义了某宏定义标识符，#ifndef 如果没有定义某宏定义标识符</p><p>语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> 宏名称</span><br>程序块<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> 宏名称</span><br>程序块<br><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p>通常在一个 C++ 程序中，包含两类文件——.cpp 文件和 .h 文件。.cpp 文件被称为 C++ 源文件，.h 文件被称为 C++ 头文件</p><p>C++ 语言支持“分别编译”，b.cpp 中想要调用 a.cpp 中定义的函数，并不需要知道 a.cpp 的存在，只需要添加 a.cpp 函数相对应的声明。定义只能定义一次，声明可以多次声明</p><p>如 a.cpp 中定义个一个 add 的函数</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 b.cpp 中可以这样使用</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">add</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a, <span class="hljs-built_in">int</span> b</span>)</span>; <span class="hljs-comment">//先声明</span><br><span class="hljs-keyword">add</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><p>源文件中维护大量的声明特别麻烦，同时会带来多次声明的重复工作。一旦定义发生改变，需要修改的地方众多</p><p>所以 C++ 语言提出了头文件的概念。你只需要在头文件中声明一次，在实现文件中定义一次。在所有需要用的文件中，就只需要引用这个头文件，相当于每个文件都包含了一个声明</p><p>头文件中应该包含下面内容：</p><ul><li>类的声明(包含类里面的成员和方法)</li><li>函数原型</li><li>#define 常量</li></ul><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>因为 C++ 中不存在 Java 的 package 概念，对于不用库相同名称的函数、变量等无法区分，所以引入了命名空间的概念</p><p>语法如下：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">namespace</span> <span class="hljs-symbol">namespace_name</span>&#123;<br><span class="hljs-comment">// 程序块</span><br>code<br>&#125;<br></code></pre></td></tr></table></figure><p>为了调用命名空间的函数或变量，需要在前面加上命名空间的名称</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">namespace_name::code<br></code></pre></td></tr></table></figure><p>您可以使用 using namespace 指令，这样在使用命名空间时就可以不用在前面加上命名空间的名称。这个指令会告诉编译器，后续的代码将使用指定的命名空间中的名称</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-keyword">namespace</span>_name;<br>code;<br></code></pre></td></tr></table></figure><h3 id="extern-关键字"><a href="#extern-关键字" class="headerlink" title="extern 关键字"></a>extern 关键字</h3><p>extern可以置于变量或者函数前，以标示变量或者函数的定义在别的文件中，提示编译器遇到此变量和函数时在其他模块中寻找其定义，表明当前只是声明</p><p>当 extern 和 “C” 一起使用的使用有其他含义，如: extern “C” void fun(int a, int b)。告诉编译器在编译 fun 这个函数名时按着 C 的规则去翻译相应的函数名而不是 C++ 的，C++ 的规则在翻译这个函数名时会把 fun 这个名字变得面目全非</p><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>跟 Java 类似，语法如下：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">try</span><br>&#123;<br>   <span class="hljs-comment">// 保护代码</span><br>&#125;<span class="hljs-keyword">catch</span>( ExceptionName e1 )<br>&#123;<br>   <span class="hljs-comment">// catch 块</span><br>&#125;<span class="hljs-keyword">catch</span>( ExceptionName e2 )<br>&#123;<br>   <span class="hljs-comment">// catch 块</span><br>&#125;<span class="hljs-keyword">catch</span>( ExceptionName eN )<br>&#123;<br>   <span class="hljs-comment">// catch 块</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>NDK开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NDK开发</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跟我一起学NDK-CMake必知必会</title>
    <link href="/2021/07/13/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%AD%A6NDK-CMake%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/"/>
    <url>/2021/07/13/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%AD%A6NDK-CMake%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A/</url>
    
    <content type="html"><![CDATA[<h3 id="CMake-简介"><a href="#CMake-简介" class="headerlink" title="CMake 简介"></a>CMake 简介</h3><p>CMake 构建脚本是一个纯文本文件，您必须将其命名为 CMakeLists.txt，并在其中包含 CMake 构建您的 C/C++ 库时需要使用的命令。如果您的原生源代码文件还没有 CMake 构建脚本，您需要自行创建一个，并在其中包含适当的 CMake 命令</p><p>本部分将介绍您应该在构建脚本中包含哪些基本命令，以便指示 CMake 在创建原生库时使用哪些源代码文件。如需了解详情，请参阅 CMake 官方文档: <a href="https://cmake.org/cmake/help/latest/manual/cmake-commands.7.html">https://cmake.org/cmake/help/latest/manual/cmake-commands.7.html</a></p><h3 id="CMake-常用语法"><a href="#CMake-常用语法" class="headerlink" title="CMake 常用语法"></a>CMake 常用语法</h3><p>推荐使用 CMake 3.6.0 的版本，因为默认的 3.10.2 在日志显示上会有问题。在 build.gradle 文件 android 域中修改 CMake 的版本</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">android</span> &#123;<br>    <span class="hljs-section">externalNativeBuild</span> &#123;<br>        <span class="hljs-section">cmake</span> &#123;<br>            <span class="hljs-attribute">path</span> file(<span class="hljs-string">&#x27;src/main/cpp/CMakeLists.txt&#x27;</span>)<br>            version <span class="hljs-string">&#x27;3.6.0&#x27;</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>CMake 的语法具体包含以下几类</p><ul><li>CMake 的基础语法</li><li>c++ 文件编译成 so 的语法</li><li>so 动态库之前相互关联的语法</li></ul><h4 id="使用-作为注释开头"><a href="#使用-作为注释开头" class="headerlink" title="使用 # 作为注释开头"></a>使用 # 作为注释开头</h4><h4 id="CMake-指令大小写不敏感，参数和变量大小写敏感"><a href="#CMake-指令大小写不敏感，参数和变量大小写敏感" class="headerlink" title="CMake 指令大小写不敏感，参数和变量大小写敏感"></a>CMake 指令大小写不敏感，参数和变量大小写敏感</h4><p>Android 中推荐使用小写</p><h4 id="变量使用-方式取值，但是在-if-控制语句中直接使用变量名"><a href="#变量使用-方式取值，但是在-if-控制语句中直接使用变量名" class="headerlink" title="变量使用 ${} 方式取值，但是在 if 控制语句中直接使用变量名"></a>变量使用 ${} 方式取值，但是在 if 控制语句中直接使用变量名</h4><h4 id="逻辑操作，跟-python-有些类似"><a href="#逻辑操作，跟-python-有些类似" class="headerlink" title="逻辑操作，跟 python 有些类似"></a>逻辑操作，跟 python 有些类似</h4><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-variable"><span class="hljs-literal">true</span></span>)</span><br>    <span class="hljs-function"><span class="hljs-title">message</span>(<span class="hljs-string">&quot;this is true&quot;</span>)</span><br><span class="hljs-function"><span class="hljs-title">else</span>()</span><br>    <span class="hljs-function"><span class="hljs-title">message</span>(<span class="hljs-string">&quot;this is false&quot;</span>)</span><br></code></pre></td></tr></table></figure><p><font color=#FF8C00>可以用于根据不同平台去编译不同平台的 so 库</font></p><h4 id="set-指令"><a href="#set-指令" class="headerlink" title="set 指令"></a>set 指令</h4><p>语法：set(VAR [VALUE])</p><p>显示定义变量，例如：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 定义一个叫 name 的变量</span><br><span class="hljs-function"><span class="hljs-title">set</span><span class="hljs-params">(name 刘小帅)</span></span><br></code></pre></td></tr></table></figure><h4 id="message-指令"><a href="#message-指令" class="headerlink" title="message 指令"></a>message 指令</h4><p>向终端打印日志：编译过程打印日志；例如：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 打印定义的 name 变量</span><br><span class="hljs-function"><span class="hljs-title">message</span><span class="hljs-params">($&#123;name&#125;)</span></span><br></code></pre></td></tr></table></figure><h4 id="cmake-minimum-required-指令"><a href="#cmake-minimum-required-指令" class="headerlink" title="cmake_minimum_required 指令"></a>cmake_minimum_required 指令</h4><p>规定 CMake 最低版本，例如：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cmake_minimum_required</span>(VERSION <span class="hljs-number">3</span>.<span class="hljs-number">4</span>.<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h4 id="project-指令"><a href="#project-指令" class="headerlink" title="project 指令"></a>project 指令</h4><p>定义 CMake 工程名称，例如：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">project</span><span class="hljs-params">(<span class="hljs-string">&quot;testndk&quot;</span>)</span></span><br></code></pre></td></tr></table></figure><h4 id="include-directories-指令"><a href="#include-directories-指令" class="headerlink" title="include_directories 指令"></a>include_directories 指令</h4><p>语法：include_directories([AFTER | BEFORE] [SYSTEM] dir1 dir2…)</p><p>可以用来向工程添加多个特定的头文件搜索路径(可以用&lt;&gt;引用)，路径之间用空格分割，如果路径中包含了空格，可以使用双引号将它括起来，默认的行为是追加到当前的头文件搜索路径的后面，例如：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//将 people 文件夹下的头文件添加到搜索路径</span><br><span class="hljs-keyword">include</span><span class="hljs-constructor">_directories(<span class="hljs-params">people</span><span class="hljs-operator">/</span>)</span> <br></code></pre></td></tr></table></figure><h4 id="add-library-指令"><a href="#add-library-指令" class="headerlink" title="add_library 指令"></a>add_library 指令</h4><p>语法：add_library(name [SHARED | STATIC | MODULE] [EXCLUDE_FROM_ALL] [source])</p><p>将一组 cpp 源文件编译出一个库文件，并保存为 libname.so (lib 前缀是生成文件时 CMake 自动添加上去的)。其中有三种库文件类型，不写的话，默认为 STATIC</p><ul><li>SHARED: 表示动态库，可以在(Java)代码中使用 System.loadLibrary(name) 动态调用</li><li>STATIC: 表示静态库，集成到代码中会在编译时调用</li><li>MODULE: 只有在使用 dyId 的系统有效，如果不支持 dyId，则被当作 SHARED 对待</li></ul><p>add_library 命令也可以用来导入第三方的库:<br>add_library(libname [SHARED | STATIC | MODULE | UNKNOWN] IMPORTED)<br>例如，导入 opencv.so</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">add_library</span><span class="hljs-params">(opencv SHARED IMPORTED)</span></span><br></code></pre></td></tr></table></figure><h4 id="set-target-properties-指令"><a href="#set-target-properties-指令" class="headerlink" title="set_target_properties 指令"></a>set_target_properties 指令</h4><p>语法：set_target_properties(target1 target2 … PROPERTIES prop1 value1 prop2 value2 …)</p><p>这条指令可以用来设置输出的名称（设置构建同名的动态库和静态库，或者指定要导入的库文件的路径），例如：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 设置 opencv 库的路径<br>set_target_properties(opencv<br>        PROPERTIES IMPORTED_LOCATION<br>        <span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span><span class="hljs-regexp">/../</span>jniLibs<span class="hljs-regexp">/$&#123;ANDROID_ABI&#125;/</span>libopencv_java3.so)<br></code></pre></td></tr></table></figure><h4 id="find-library-指令"><a href="#find-library-指令" class="headerlink" title="find_library 指令"></a>find_library 指令</h4><p>查找 NDK 已经存在的 so 动态库，例如：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">find<span class="hljs-constructor">_library(<span class="hljs-params">log</span>-<span class="hljs-params">lib</span> <span class="hljs-params">log</span>)</span><br></code></pre></td></tr></table></figure><h4 id="target-link-libraries-指令"><a href="#target-link-libraries-指令" class="headerlink" title="target_link_libraries 指令"></a>target_link_libraries 指令</h4><p>语法：target_link_libraries(target library &lt;debug | optimized&gt; library2…)</p><p>共享库关联，以便相互调用函数，例如：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 关联 native-lib 和 log-lib 两个动态库</span><br>target<span class="hljs-constructor">_link_libraries(<span class="hljs-params">native</span>-<span class="hljs-params">lib</span> $&#123;<span class="hljs-params">log</span>-<span class="hljs-params">lib</span>&#125;)</span><br></code></pre></td></tr></table></figure><h4 id="经常用的常量"><a href="#经常用的常量" class="headerlink" title="经常用的常量"></a>经常用的常量</h4><ul><li>CMAKE_CURRENT_LIST_FILE 当前 CMake 文件的路径</li><li>CMAKE_CURRENT_LIST_DIR 当前 CMake 文件夹的路径</li><li>ANDROID_ABI 当前在打的 so 对应的 cpu 架构</li></ul><p><font color=#FF8C00>这些路径对于引用其他的库非常有用</font></p><h3 id="动态库的来源"><a href="#动态库的来源" class="headerlink" title="动态库的来源"></a>动态库的来源</h3><p>动态库的来源总共就三类：</p><ol><li>基于 cpp 源文件打的动态库</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">add<span class="hljs-constructor">_library(<span class="hljs-params">native</span>-<span class="hljs-params">lib</span> SHARED <span class="hljs-params">native</span>-<span class="hljs-params">lib</span>.<span class="hljs-params">cpp</span> )</span><br></code></pre></td></tr></table></figure><ol start="2"><li>NDK 中查找存在的动态库</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">find<span class="hljs-constructor">_library(<span class="hljs-params">log</span>-<span class="hljs-params">lib</span> <span class="hljs-params">log</span>)</span><br></code></pre></td></tr></table></figure><ol start="3"><li>自己在 jniLibs 中添加的三方动态库</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">add_library(opencv SHARED IMPORTED)<br><span class="hljs-regexp">//</span> add_library 必须在前<br>set_target_properties(opencv<br>        PROPERTIES IMPORTED_LOCATION<br>        <span class="hljs-variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span><span class="hljs-regexp">/../</span>jniLibs<span class="hljs-regexp">/$&#123;ANDROID_ABI&#125;/</span>libopencv_java3.so)<br></code></pre></td></tr></table></figure><h3 id="理解示例工程"><a href="#理解示例工程" class="headerlink" title="理解示例工程"></a>理解示例工程</h3><p>现在我们再来看下之前示例工程创建的 CMakeLists.txt 的内容就会更加清晰</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">cmake_minimum_required</span><span class="hljs-params">(VERSION <span class="hljs-number">3.10</span>.<span class="hljs-number">2</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">project</span><span class="hljs-params">(<span class="hljs-string">&quot;testndk&quot;</span>)</span></span><br><br>add_library( <br>             native-lib<br>             SHARED<br>             native-lib<span class="hljs-selector-class">.cpp</span> )<br><br>find_library(<br>              log-lib<br>              log )<br><br>target_link_libraries( <br>                       native-lib<br>                       $&#123;log-lib&#125; )<br></code></pre></td></tr></table></figure><ol><li>设置了最低的 CMake 版本为 3.10.2</li><li>将当前 CMake 工程命名为 testndk</li><li>将 native-lib.cpp 文件打成动态库 libnative-lib.so</li><li>查找本地 log 库，并重命名为 log-lib</li><li>将 native-lib 和 log-lib 两个动态库关联，以便在 native-lib.cpp 内部使用 log 库的函数</li></ol><h3 id="CMake-构建产物"><a href="#CMake-构建产物" class="headerlink" title="CMake 构建产物"></a>CMake 构建产物</h3><p>CMake 构建的产物在 build/intermediates 文件夹下，默认构建所有 cpu 架构的产物</p><p><img src="/img/ndk_7.png" alt="构建产物"></p><p>可以在 android 域的 defaultConfig 下指定需要构建的 cpu 架构</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-comment">// 指定只打 v7a 和 v8a 的 so</span><br><span class="hljs-class">android </span>&#123;<br>  <span class="hljs-class">defaultConfig </span>&#123;<br>  <span class="hljs-class">externalNativeBuild </span>&#123; <br>  <span class="hljs-class">ndk </span>&#123;<br>     abiFilters <span class="hljs-string">&quot;armeabi-v7a&quot;</span>, <span class="hljs-string">&quot;arm64-v8a&quot;</span><br>  &#125;<br>  &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>NDK开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NDK开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跟我一起学NDK-NDK开发环境搭建</title>
    <link href="/2021/07/12/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%AD%A6NDK-NDK%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/2021/07/12/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%AD%A6NDK-NDK%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h3 id="为什么需要-NDK"><a href="#为什么需要-NDK" class="headerlink" title="为什么需要 NDK"></a>为什么需要 NDK</h3><p>总的来说 NDK 在下面两个场景派上用场</p><ul><li>进一步提升设备性能，以降低延迟或运行游戏或物理模拟等计算密集型应用</li><li>重复使用您自己或其他开发者的 C 或 C++ 库</li></ul><p>原生开发套件 (NDK) 是一套工具，使您能够在 Android 应用中使用 C 和 C++ 代码，并提供众多平台库，您可使用这些平台库管理原生 Activity 和访问实体设备组件，例如传感器和触摸输入</p><h3 id="搭建-NDK-开发环境"><a href="#搭建-NDK-开发环境" class="headerlink" title="搭建 NDK 开发环境"></a>搭建 NDK 开发环境</h3><p>如需为您的应用编译和调试原生代码，您需要以下组件：</p><ul><li>Android 原生开发套件 (NDK)：这套工具使您能在 Android 应用中使用 C 和 C++ 代码</li><li>CMake：一款外部构建工具，可与 Gradle 搭配使用来构建原生库</li><li>LLDB：Android Studio 用于调试原生代码的调试程序</li></ul><p><strong>编译原生库也可以使用 ndk-build，和 CMake 两者选一，不可混用。Android Studio2.3 版本之后 默认构建工具是 CMake，因此本教程只讲解 CMake</strong></p><h4 id="下载-NDK-和-CMake"><a href="#下载-NDK-和-CMake" class="headerlink" title="下载 NDK 和 CMake"></a>下载 NDK 和 CMake</h4><p>当您安装 NDK 时，Android Studio 会选择可用的最新 NDK 版本。对于大多数项目，安装此默认版本的 NDK 已经足够。不过，如果您的项目需要一个或多个特定版本的 NDK，您可以下载并配置特定版本。当多个项目各自依赖于特定版本的 NDK 时，这样做有助于确保各个项目的 build 都可重现。Android Studio 会将所有版本的 NDK 安装在 sdkdir/ndk/ 目录中。</p><p>如需在 Android Studio 中安装 CMake 和默认 NDK，请执行以下操作：</p><ol><li>打开项目后，依次点击 Tools &gt; SDK Manager</li><li>点击 SDK Tools 标签页</li><li>选中 NDK (Side by side) 和 CMake 复选框</li></ol><p><img src="/img/ndk_1.png" alt="ndk安装"></p><ol start="4"><li>点击 OK</li><li>此时系统会显示一个对话框，告诉您 NDK 软件包占用了多少磁盘空间</li><li>点击 OK</li><li>安装完成后，点击 Finish</li><li>您的项目会自动同步 build 文件并执行构建。修正发生的所有错误</li></ol><h4 id="下载特定版本的-NDK"><a href="#下载特定版本的-NDK" class="headerlink" title="下载特定版本的 NDK"></a>下载特定版本的 NDK</h4><p>要安装特定版本的 NDK，请执行以下操作：</p><ol><li>打开项目后，依次点击 Tools &gt; SDK Manager</li><li>点击 SDK Tools 标签页</li><li>选中 Show Package Details 复选框</li><li>选中 NDK (Side by side) 复选框及其下方与您想要安装的 NDK 版本对应的复选框Android Studio 会将所有版本的 NDK 安装在 sdkdir/ndk/ 目录中</li></ol><p><img src="/img/ndk_2.png" alt="ndk安装"></p><ol start="5"><li>点击 OK</li><li>此时系统会显示一个对话框，告诉您 NDK 软件包占用了多少磁盘空间</li><li>点击 OK</li><li>安装完成后，点击 Finish</li><li>您的项目会自动同步 build 文件并执行构建。修正发生的所有错误</li></ol><h3 id="创建支持-c-c-的新项目"><a href="#创建支持-c-c-的新项目" class="headerlink" title="创建支持 c/c++ 的新项目"></a>创建支持 c/c++ 的新项目</h3><p>创建支持原生代码的新项目的步骤与创建任何其他 Android Studio 项目的步骤相似</p><ol><li>在向导的 Choose your project 部分中，选择 Native C++ 项目类型</li><li>点击 Next</li><li>填写向导下一部分中的所有其他字段</li><li>点击 Next</li><li>在向导的 Customize C++ Support 部分中，您可以使用 C++ Standard 字段自定义项目。使用下拉列表选择您想要使用哪种 C++ 版本。选择 Toolchain Default 可使用默认的 CMake 设置</li><li>点击 Finish</li></ol><p>在 Android Studio 完成新项目的创建后，请从 IDE 左侧打开 Project 窗格，然后选择 Android 视图。如图所示，Android Studio 会添加 cpp 组：</p><p><img src="/img/ndk_3.png" alt="ndk项目结构"></p><h3 id="现有项目支持-c-c"><a href="#现有项目支持-c-c" class="headerlink" title="现有项目支持 c/c++"></a>现有项目支持 c/c++</h3><ol><li>项目切换到 Project，在 main 下新建 cpp 文件夹</li><li>新建 CMakeLists.txt 文件放在 cpp 文件夹下。并新增如下内容：</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">cmake_minimum_required</span><span class="hljs-params">(VERSION <span class="hljs-number">3.10</span>.<span class="hljs-number">2</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">project</span><span class="hljs-params">(<span class="hljs-string">&quot;testndk&quot;</span>)</span></span><br><br>add_library( <br>             native-lib<br>             SHARED<br>             native-lib<span class="hljs-selector-class">.cpp</span> )<br><br>find_library(<br>              log-lib<br>              log )<br><br>target_link_libraries( <br>                       native-lib<br>                       $&#123;log-lib&#125; )<br></code></pre></td></tr></table></figure><ol start="3"><li>新建 native-lib.cpp 文件放在 cpp 文件夹下。并新增如下内容：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;jni.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">&quot;C&quot;</span> <span class="hljs-function">JNIEXPORT jstring JNICALL</span><br><span class="hljs-function"><span class="hljs-title">Java_com_netease_nis_testndk_MainActivity_stringFromJNI</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        JNIEnv* env,</span></span><br><span class="hljs-params"><span class="hljs-function">        jobject <span class="hljs-comment">/* this */</span>)</span> </span>&#123;<br>    std::string hello = <span class="hljs-string">&quot;Hello from C++&quot;</span>;<br>    <span class="hljs-keyword">return</span> env-&gt;<span class="hljs-built_in">NewStringUTF</span>(hello.<span class="hljs-built_in">c_str</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>中间的com_netease_nis_testndk换成自己的包名</strong></p><ol start="4"><li>build.gradle 关联 CMake。在 android 域下添加如下内容</li></ol><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">externalNativeBuild</span> &#123;<br>       <span class="hljs-section">cmake</span> &#123;<br>           <span class="hljs-attribute">path</span> file(<span class="hljs-string">&#x27;src/main/cpp/CMakeLists.txt&#x27;</span>)<br>           version <span class="hljs-string">&#x27;3.10.2&#x27;</span><br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>然后就可以在应用层调用原生库了</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> MainActivity extends AppCompatActivity &#123;<br>    static &#123;<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>load<span class="hljs-constructor">Library(<span class="hljs-string">&quot;native-lib&quot;</span>)</span>;<br>    &#125;<br><br>    @Override<br>    protected void on<span class="hljs-constructor">Create(Bundle <span class="hljs-params">savedInstanceState</span>)</span> &#123;<br>        super.on<span class="hljs-constructor">Create(<span class="hljs-params">savedInstanceState</span>)</span>;<br>        set<span class="hljs-constructor">ContentView(R.<span class="hljs-params">layout</span>.<span class="hljs-params">activity_main</span>)</span>;<br><br>        ((TextView)find<span class="hljs-constructor">ViewById(R.<span class="hljs-params">id</span>.<span class="hljs-params">tv</span>)</span>).set<span class="hljs-constructor">Text(<span class="hljs-params">stringFromJNI</span>()</span>);<br>    &#125;<br><br>    public native String <span class="hljs-built_in">string</span><span class="hljs-constructor">FromJNI()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="NDK-和-Gradle-插件"><a href="#NDK-和-Gradle-插件" class="headerlink" title="NDK 和 Gradle 插件"></a>NDK 和 Gradle 插件</h3><p>从上面的 NDK 开发环境搭建过程中我们并没有看到 NDK 相关的配置，那怎么就可以在应用中使用 c/c++ 代码了呢？其实 Gradle 插件指定了默认的 NDK 版本</p><table><thead><tr><th>Android Studio/Gradle 插件版本</th><th>为 AGP 版本指定的默认 NDK 版本</th></tr></thead><tbody><tr><td>4.2</td><td>21.4.7075529</td></tr><tr><td>4.1</td><td>21.1.6352462</td></tr><tr><td>4.0</td><td>21.0.6113669</td></tr><tr><td>3.6</td><td>20.0.5594570</td></tr><tr><td>3.4、3.5</td><td>未指定默认版本</td></tr></tbody></table><p>可以通过在 android 域中指定特定的版本来改变默认的 NDK 版本：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">android &#123;<br>    ndkVersion = <span class="hljs-string">&quot;major.minor.build&quot;</span> <span class="hljs-regexp">//</span> 如ndkVersion <span class="hljs-string">&quot;21.3.6528147&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="构建和运行示例应用"><a href="#构建和运行示例应用" class="headerlink" title="构建和运行示例应用"></a>构建和运行示例应用</h3><p>点击 Run 图标从菜单栏运行应用后，Android Studio 会构建并启动一个应用，此应用会在您的 Android 设备或模拟器上显示文字“Hello from C++”。下面的概览介绍了在构建和运行示例应用时会发生的事件：</p><ol><li>Gradle 调用您的外部构建脚本 CMakeLists.txt</li><li>CMake 按照构建脚本中的命令将 C++ 源代码文件 native-lib.cpp 编译到共享的对象库中，并将其命名为 libnative-lib.so，Gradle 随后会将后者打包到 APK 中</li><li>在运行时，应用的 MainActivity 使用 System.loadLibrary() 加载原生库。现在，应用就可以使用库的原生函数 stringFromJNI() 了</li><li>MainActivity.onCreate() 调用 stringFromJNI()，后者会返回“Hello from C++”，并使用它更新 TextView 文本</li></ol><p><img src="/img/ndk_4.jpeg" alt="运行结果"></p><h3 id="NDK-断点调试"><a href="#NDK-断点调试" class="headerlink" title="NDK 断点调试"></a>NDK 断点调试</h3><p>NDK 断点调试和 Java 类似，打断点之后 Debug。只是 NDK 断点调试会另启一个 LLDB 的服务，这个服务依赖于 Host 的配置，否则会报如下错误：</p><p><img src="/img/ndk_5.png" alt="没有配置host"></p><p>配置 host 可以借助于 SwitchHosts，然后在 SwitchHosts 添加如下 host</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1</span> localhost<br></code></pre></td></tr></table></figure><p>华为手机 NDK 断点调试还会出现如下问题，目前还没找到解决方法。找到解决方法的读者可以在下方留言哈</p><p><img src="/img/ndk_6.png" alt="华为手机异常"></p>]]></content>
    
    
    <categories>
      
      <category>NDK开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NDK开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>手把手教你发布Android库到MavenCentral</title>
    <link href="/2021/07/07/mavenCentral/"/>
    <url>/2021/07/07/mavenCentral/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>最近一则JCenter将要关闭的消息搞得人心惶惶。作为Google默认钦定的开源远程仓库，这么些年估计免费帮Google干活干腻了。抛开两家公司的利益冲突，我们来聊一下对我们开发的影响。我们知道之前有非常多的三方库是托管在Jcenter上的，甚至不少库有可能没有同步到其他远程仓库。一旦JCenter关闭，我们的项目编译甚至都会受到影响。</p><h5 id="小提示"><a href="#小提示" class="headerlink" title="小提示"></a>小提示</h5><p>万一直到Jencter关闭的时候，项目中有使用到还没来得及迁移的库。我们可以配置一下阿里云的镜像，阿里云镜像会同步各大远程仓库。在根build.gradle添加如下配置：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">maven</span> &#123;<span class="hljs-attribute">url</span> <span class="hljs-string">&#x27;https://maven.aliyun.com/repository/public&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><p>各大仓库对应的镜像如下表所示</p><table><thead><tr><th>仓库名称</th><th>阿里云仓库地址</th><th>源地址</th></tr></thead><tbody><tr><td>mavenCentral</td><td><a href="https://maven.aliyun.com/repository/central">https://maven.aliyun.com/repository/central</a></td><td><a href="https://repo1.maven.org/maven2/">https://repo1.maven.org/maven2/</a></td></tr><tr><td>Jcenter</td><td><a href="https://maven.aliyun.com/repository/public">https://maven.aliyun.com/repository/public</a></td><td><a href="http://jcenter.bintray.com/">http://jcenter.bintray.com/</a></td></tr><tr><td>public</td><td><a href="https://maven.aliyun.com/repository/public">https://maven.aliyun.com/repository/public</a></td><td>central仓和jcenter仓的聚合仓</td></tr><tr><td>google</td><td><a href="https://maven.aliyun.com/repository/google">https://maven.aliyun.com/repository/google</a></td><td><a href="https://maven.google.com/">https://maven.google.com/</a></td></tr></tbody></table><h5 id="官方信息"><a href="#官方信息" class="headerlink" title="官方信息"></a>官方信息</h5><p><img src="/img/mavenCentral_1.png"></p><p>从jFrog官方的说明来看，自2021年3月1号开始，JFrog将不再接受任何新的提交，包括新库的提交和老库的更新。不过之前提交的还是可以继续使用到2022年2月1日。</p><p><img src="/img/mavenCentral_2.png"></p><p>最新版本的Android Studio也提示了JCenter将废弃。<br>看来情况还没有那么糟糕，JCenter不会立马关闭，JFrog还是预留了一点时间让我们做库迁移的。话虽如此，我们还是要尽早迁移，尤其是做sdk开发的。那么该往哪儿迁移呢？让我们来对比下目前市面上的几大远程仓库：</p><ul><li>Google 谷歌自用，不给广大开发者使用，还真是小气</li><li>Jcenter 性能和存储大小有优势，这也是之前google默认使用它的原因</li><li>mavenCentral 和JCenter齐名，发布流程比较长，对开发者不友好</li></ul><p>对比了之后我们别无选择只能迁移到MavenCentral,接下来就来讲一下如何将库发布到MavenCentral。</p><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>与jCenter是由jForg运营，在bintray.com做管理一样，Maven Central是由sonatype运营的，那么首先需要去注册一个sonatype的账号并获得仓库使用许可。</p><p>先前往<a href="https://issues.sonatype.org/">https://issues.sonatype.org</a>注册账号，界面如图：</p><p><img src="/img/mavenCentral_3.png"></p><p>注册完登录进去之后需要提一个Issue，sonatype创建仓库以Issue的形式。</p><p><img src="/img/mavenCentral_4.png"></p><p><img src="/img/mavenCentral_5.png"></p><p>其他按要求填写即可，最重要的是Group Id。之后提交的所有库都是在这个Group Id下，最简单的命名是以io.github开头后跟github的名字,如io.github.liulingfeng。当然也可以按照你的域名翻转作为你的Group Id。两者认证方式不同，以io.github.liulingfeng为Group Id的只需要在github上创建一个public的项目就行；使用自己的域名，需要按照官方的要求，在DNS配置配置一个TXT记录指向你的Github地址来完成验证，比较麻烦，具体参考<a href="https://central.sonatype.org/publish/">https://central.sonatype.org/publish/</a>。</p><p>申请后请耐心等待官方的回复，待issues状态变为已解决，那么就说明申请成功了，如果有任何错误，审核人员会在下方给出注释，你也可以通过备注回复审核人员完成申请。</p><p><img src="/img/mavenCentral_6.png"></p><p><img src="/img/mavenCentral_7.png"></p><h3 id="Gradle-配置"><a href="#Gradle-配置" class="headerlink" title="Gradle 配置"></a>Gradle 配置</h3><h5 id="首先引入dokka-gradle-plugin插件"><a href="#首先引入dokka-gradle-plugin插件" class="headerlink" title="首先引入dokka-gradle-plugin插件"></a>首先引入dokka-gradle-plugin插件</h5><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">classpath</span> <span class="hljs-string">&quot;org.jetbrains.dokka:dokka-gradle-plugin:1.4.10.2&quot;</span><br></code></pre></td></tr></table></figure><h5 id="在需要发布的Moudle根目录下创建publish-gradle文件"><a href="#在需要发布的Moudle根目录下创建publish-gradle文件" class="headerlink" title="在需要发布的Moudle根目录下创建publish.gradle文件"></a>在需要发布的Moudle根目录下创建publish.gradle文件</h5><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs gradle">apply plugin: <span class="hljs-string">&#x27;maven-publish&#x27;</span><br>apply plugin: <span class="hljs-string">&#x27;signing&#x27;</span><br><br><span class="hljs-keyword">task</span> androidSourcesJar(type: Jar) &#123;<br>    classifier = <span class="hljs-string">&#x27;sources&#x27;</span><br>&#125;<br><br>ext &#123;<br>    PUBLISH_GROUP_ID = <span class="hljs-string">&#x27;Group Id&#x27;</span><br>    PUBLISH_ARTIFACT_ID = <span class="hljs-string">&#x27;Artifact Id&#x27;</span><br>    PUBLISH_VERSION = <span class="hljs-string">&#x27;版本号&#x27;</span><br>&#125;<br><br>ext[<span class="hljs-string">&quot;signing.keyId&quot;</span>] = <span class="hljs-string">&#x27;&#x27;</span><br>ext[<span class="hljs-string">&quot;signing.password&quot;</span>] = <span class="hljs-string">&#x27;&#x27;</span><br>ext[<span class="hljs-string">&quot;signing.secretKeyRingFile&quot;</span>] = <span class="hljs-string">&#x27;&#x27;</span><br>ext[<span class="hljs-string">&quot;ossrhUsername&quot;</span>] = <span class="hljs-string">&#x27;&#x27;</span><br>ext[<span class="hljs-string">&quot;ossrhPassword&quot;</span>] = <span class="hljs-string">&#x27;&#x27;</span><br><br><span class="hljs-keyword">File</span> secretPropsFile = <span class="hljs-keyword">project</span>.rootProject.<span class="hljs-keyword">file</span>(<span class="hljs-string">&#x27;local.properties&#x27;</span>)<br><span class="hljs-keyword">if</span> (secretPropsFile.exists()) &#123;<br>    <span class="hljs-keyword">println</span> <span class="hljs-string">&quot;Found secret props file, loading props&quot;</span><br>    Properties p = <span class="hljs-keyword">new</span> Properties()<br>    p.load(<span class="hljs-keyword">new</span> FileInputStream(secretPropsFile))<br>    p.<span class="hljs-keyword">each</span> &#123; name, value -&gt;<br>        ext[name] = value<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">println</span> <span class="hljs-string">&quot;No props file, loading env vars&quot;</span><br>&#125;<br>publishing &#123;<br>    publications &#123;<br>        release(MavenPublication) &#123;<br>            <span class="hljs-comment">// The coordinates of the library, being set from variables that</span><br>            <span class="hljs-comment">// we&#x27;ll set up in a moment</span><br>            groupId PUBLISH_GROUP_ID<br>            artifactId PUBLISH_ARTIFACT_ID<br>            version PUBLISH_VERSION<br>            <br>            <span class="hljs-comment">// Two artifacts, the `aar` and the sources</span><br>            artifact(<span class="hljs-string">&quot;$buildDir/outputs/aar/$&#123;project.getName()&#125;-release.aar&quot;</span>)<br>            artifact androidSourcesJar<br><br>            <span class="hljs-comment">// Self-explanatory metadata for the most part</span><br>            pom &#123;<br>                name = PUBLISH_ARTIFACT_ID<br>                <span class="hljs-keyword">description</span> = <span class="hljs-string">&#x27;描述信息&#x27;</span><br>                <span class="hljs-comment">// If your project has a dedicated site, use its URL here</span><br>                url = <span class="hljs-string">&#x27;官网&#x27;</span><br>                licenses &#123;<br>                    license &#123;<br>                        <span class="hljs-comment">//协议类型，一般默认Apache License2.0的话不用改：</span><br>                        name = <span class="hljs-string">&#x27;The Apache License, Version 2.0&#x27;</span><br>                        url = <span class="hljs-string">&#x27;http://www.apache.org/licenses/LICENSE-2.0.txt&#x27;</span><br>                    &#125;<br>                &#125;<br>                developers &#123;<br>                    developer &#123;<br>                        id = <span class="hljs-string">&#x27;sonatype注册的用户名&#x27;</span><br>                        name = <span class="hljs-string">&#x27;sonatype注册的用户名&#x27;</span><br>                        email = <span class="hljs-string">&#x27;sonatype注册的邮箱&#x27;</span><br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// Version control info, if you&#x27;re using GitHub, follow the format as seen here</span><br>                scm &#123;<br>                    <span class="hljs-comment">//修改成你的Git地址：</span><br>                    connection = <span class="hljs-string">&#x27;scm:git:项目git地址&#x27;</span><br>                    developerConnection = <span class="hljs-string">&#x27;scm:git:项目git ssh地址&#x27;</span><br>                    <span class="hljs-comment">//分支地址：</span><br>                    url = <span class="hljs-string">&#x27;分支&#x27;</span><br>                &#125;<br>                <span class="hljs-comment">// A slightly hacky fix so that your POM will include any transitive dependencies</span><br>                <span class="hljs-comment">// that your library builds upon</span><br>                withXml &#123;<br>                    <span class="hljs-keyword">def</span> dependenciesNode = asNode().appendNode(<span class="hljs-string">&#x27;dependencies&#x27;</span>)<br><br>                    <span class="hljs-keyword">project</span>.<span class="hljs-keyword">configurations</span>.implementation.allDependencies.<span class="hljs-keyword">each</span> &#123;<br>                        <span class="hljs-keyword">def</span> dependencyNode = dependenciesNode.appendNode(<span class="hljs-string">&#x27;dependency&#x27;</span>)<br>                        dependencyNode.appendNode(<span class="hljs-string">&#x27;groupId&#x27;</span>, it.<span class="hljs-keyword">group</span>)<br>                        dependencyNode.appendNode(<span class="hljs-string">&#x27;artifactId&#x27;</span>, it.name)<br>                        dependencyNode.appendNode(<span class="hljs-string">&#x27;version&#x27;</span>, it.version)<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">repositories</span> &#123;<br>        <span class="hljs-comment">// The repository to publish to, Sonatype/MavenCentral</span><br>        maven &#123;<br>            <span class="hljs-comment">// This is an arbitrary name, you may also use &quot;mavencentral&quot; or</span><br>            <span class="hljs-comment">// any other name that&#x27;s descriptive for you</span><br>            name = <span class="hljs-string">&quot;mavencentral&quot;</span><br><br>            <span class="hljs-keyword">def</span> releasesRepoUrl = <span class="hljs-string">&quot;https://s01.oss.sonatype.org/service/local/staging/deploy/maven2/&quot;</span><br>            <span class="hljs-keyword">def</span> snapshotsRepoUrl = <span class="hljs-string">&quot;https://s01.oss.sonatype.org/content/repositories/snapshots/&quot;</span><br>            <span class="hljs-comment">// You only need this if you want to publish snapshots, otherwise just set the URL</span><br>            <span class="hljs-comment">// to the release repo directly</span><br>            url = version.endsWith(<span class="hljs-string">&#x27;SNAPSHOT&#x27;</span>) ? snapshotsRepoUrl : releasesRepoUrl<br><br>            <span class="hljs-comment">// The username and password we&#x27;ve fetched earlier</span><br>            credentials &#123;<br>                username ossrhUsername<br>                password ossrhPassword<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br>signing &#123;<br>    sign publishing.publications<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="在需要发布的Moudle的build-gradle中添加对publish-gradle的依赖"><a href="#在需要发布的Moudle的build-gradle中添加对publish-gradle的依赖" class="headerlink" title="在需要发布的Moudle的build.gradle中添加对publish.gradle的依赖"></a>在需要发布的Moudle的build.gradle中添加对publish.gradle的依赖</h5><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-built_in">apply</span> <span class="hljs-keyword">from</span>: <span class="hljs-string">&quot;./publish.gradle&quot;</span><br></code></pre></td></tr></table></figure><h5 id="创建GPG秘钥-下面是mac教程，windows自行查找"><a href="#创建GPG秘钥-下面是mac教程，windows自行查找" class="headerlink" title="创建GPG秘钥(下面是mac教程，windows自行查找)"></a>创建GPG秘钥(下面是mac教程，windows自行查找)</h5><ol><li><p>在<a href="https://www.gnupg.org/download/">https://www.gnupg.org/download/</a>下载GPG客户端</p><p> <img src="/img/mavenCentral_8.png"></p></li><li><p>在命令行中执行命令gpg –full-gen-key</p></li><li><p>加密方式选择RSA and RSA，长度输入4096，过期时间直接回车不用管，然后输入一个user ID并且提供一个邮箱，我直接用的我sonatype的用户名和邮箱。最后一步输入’O’，表示OK</p></li></ol><p><img src="/img/mavenCentral_9.png"></p><ol start="4"><li>之后会弹出一个对话框，让输入密码。这会为你在~/.gnupg/openpgp-revocs.d/目录下创建一个.rev文件，记住pub的末尾8位</li><li>创建secring.gpg文件，命令行执行gpg –export-secret-keys -o secring.gpg，这会要求你输入在步骤4中设置的密码，在你用户根目录下会出现secring.gpg文件</li><li>回到gpg客户端，选择我们刚生成的秘钥条目，右键，选择Send Public Key to Key Server<h5 id="在local-properties添加如下配置"><a href="#在local-properties添加如下配置" class="headerlink" title="在local.properties添加如下配置"></a>在local.properties添加如下配置</h5><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">signing.keyId</span>=刚才生成的.rev文件秘钥后<span class="hljs-number">8</span>位<br><span class="hljs-attr">signing.password</span>=步骤<span class="hljs-number">4</span>中设置的密码<br><span class="hljs-attr">signing.secretKeyRingFile</span>=刚才生成的secring.gpg文件目录<br><span class="hljs-attr">ossrhUsername</span>=sonatype用户名<br><span class="hljs-attr">ossrhPassword</span>=sonatype密码<br></code></pre></td></tr></table></figure><h5 id="执行打包发布"><a href="#执行打包发布" class="headerlink" title="执行打包发布"></a>执行打包发布</h5>设置完这些后，在AndroidStudio右侧的gradle tasks中找到你想提交的module，先执行build生成产物</li></ol><p><img src="/img/mavenCentral_10.png"></p><p>接着执行generatePomFileForReleasePublication生成pom文件</p><p><img src="/img/mavenCentral_11.png"></p><p>生成的pom文件在如图所示的位置，最好查看下生成的pom文件是否正确。pom文件直接影响到整个gradle依赖。</p><p><img src="/img/mavenCentral_12.png">)</p><p>最后执行publishReleasePublicationToMavencentralRepository发布</p><p><img src="/img/mavenCentral_13.png"></p><h3 id="设置为所有人可见"><a href="#设置为所有人可见" class="headerlink" title="设置为所有人可见"></a>设置为所有人可见</h3><p>上传成功后，打开<a href="https://s01.oss.sonatype.org/#welcome">https://s01.oss.sonatype.org/#welcome</a>，登录你的sonatype账号，在左侧Staging Repositories页面找到你的group id，点击上边的close，等待几分钟十几分钟后刷新状态。等其状态变为closed后，再点击Release，则所有人都能使用你的库了。</p><p><img src="/img/mavenCentral_14.png"></p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><h5 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h5><p>理论上执行完上述流程之后远程依赖就可以正常使用了。神奇的是后面的某次发布过程中遇到了问题，设置完Release之后在Public Repository已经可以搜索到刚发布完的库。但是拉取远程依赖的时候死活拉不到，提示如下：</p><p><img src="/img/mavenCentral_15.png"></p><p>我们知道远程依赖会从配置的中央仓库遍历去查找，最后一个地址就是mavenCentral对应的中央仓库，点进去提示是404。而其他之前发布成功的依赖能找到，这就非常神奇，我们有必要来重新梳理一下整个发布流程：</p><p><img src="/img/mavenCentral_16.png"></p><p>后面两步是自动同步的，不需要我们操心。但就是自动同步出了问题，没有自动同步过去。实在没有办法，只好去sonatype提issue，这时候蹩脚的英语又派上了用场。</p><p><img src="/img/mavenCentral_19.png"></p><p>原来是同步基础架构中的磁盘空间出了问题，真是虚惊一场。后面遇到什么发布问题都可以在sonatype提issue得到解决，注意老外的时差问题，尽量在老外上班时间提。</p><h5 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h5><p>拉远程依赖的时候出现如下图所示的异常：</p><p><img src="/img/mavenCentral_17.png"></p><p>怎么会出现 Could not find :unspecified 呢？其实问题的关键在生成的pom文件中：</p><p><img src="/img/mavenCentral_18.png"></p><p>由于项目的依赖中有一项是本地jar依赖，所以会读不到group、name和version，值自然就是unspecified。读取的时候由于无法识别就报出了上述问题。解决方案也很简单，就是withXml的时候做一下过滤：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">withXml &#123;<br>                   def dependenciesNode = <span class="hljs-keyword">as</span><span class="hljs-constructor">Node()</span>.append<span class="hljs-constructor">Node(&#x27;<span class="hljs-params">dependencies</span>&#x27;)</span><br><br>                   project.configurations.implementation.allDependencies.each &#123;<br>                       <span class="hljs-keyword">if</span> (it.name != &#x27;unspecified&#x27;) &#123;<br>                           def dependencyNode = dependenciesNode.append<span class="hljs-constructor">Node(&#x27;<span class="hljs-params">dependency</span>&#x27;)</span><br>                           dependencyNode.append<span class="hljs-constructor">Node(&#x27;<span class="hljs-params">groupId</span>&#x27;, <span class="hljs-params">it</span>.<span class="hljs-params">group</span>)</span><br>                           dependencyNode.append<span class="hljs-constructor">Node(&#x27;<span class="hljs-params">artifactId</span>&#x27;, <span class="hljs-params">it</span>.<span class="hljs-params">name</span>)</span><br>                           dependencyNode.append<span class="hljs-constructor">Node(&#x27;<span class="hljs-params">version</span>&#x27;, <span class="hljs-params">it</span>.<span class="hljs-params">version</span>)</span><br>                       &#125;<br>                   &#125;<br>               &#125;<br></code></pre></td></tr></table></figure><p>哪个值是unspecified，就对哪个值做个判断，当然全加上更保险。</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sdk</tag>
      
      <tag>mavenCentral发布</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JsBridge源码详解</title>
    <link href="/2021/07/07/jsbridge/"/>
    <url>/2021/07/07/jsbridge/</url>
    
    <content type="html"><![CDATA[<h4>使用jsbridge的原因</h4><p>原生webview h5调用native方法使用addJavaScriptInterface，然而4.2以下系统没有对注册java类的方法做限制，导致攻击者可以利用反射调用其他未注册的任何java类。出于安全性考虑使用jsbridge来处理h5和native的交互。</p><h4>项目地址</h4><p><a href="https://github.com/lzyzsd/JsBridge">https://github.com/lzyzsd/JsBridge</a></p><h4>使用方法/两端增加的额外代码比较少</h4>1.native注册方法供h5调用<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">webView.register<span class="hljs-constructor">Handler(<span class="hljs-string">&quot;submitFromWeb&quot;</span>)</span> &#123; data, <span class="hljs-keyword">function</span> -&gt;<br>           <span class="hljs-keyword">function</span>.on<span class="hljs-constructor">CallBack(<span class="hljs-string">&quot;submitFromWeb exe, response data 中文 from Java&quot;</span>)</span><br>       &#125;<br></code></pre></td></tr></table></figure><p>2.native调用h5方法</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">webView.call<span class="hljs-constructor">Handler(<span class="hljs-string">&quot;functionInJs&quot;</span>, Gson()</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">Json(<span class="hljs-params">user</span>)</span>) &#123; data -&gt;<br>          <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>e(<span class="hljs-string">&quot;处理结果&quot;</span>, data)<br>      &#125;<br></code></pre></td></tr></table></figure><p>3.h5注册方法供native调用</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">bridge.register<span class="hljs-constructor">Handler(<span class="hljs-string">&quot;functionInJs&quot;</span>, <span class="hljs-params">function</span> (<span class="hljs-params">data</span>, <span class="hljs-params">responseCallback</span>)</span> &#123;<br>            <span class="hljs-keyword">if</span> (responseCallback) &#123;<br>                <span class="hljs-keyword">let</span> responseData = <span class="hljs-string">&quot;Javascript Says Right back aka!&quot;</span>;<br>                response<span class="hljs-constructor">Callback(<span class="hljs-params">responseData</span>)</span>;<br>            &#125;<br>        &#125;)<br></code></pre></td></tr></table></figure><p>4.h5调用native的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">window</span>.WebViewJavascriptBridge.callHandler(<br>            <span class="hljs-string">&#x27;submitFromWeb&#x27;</span><br>            , &#123;<span class="hljs-string">&#x27;param&#x27;</span>: <span class="hljs-string">&#x27;中文测试&#x27;</span>&#125;<br>            , <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">responseData</span>) </span>&#123;<br>                <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;show&quot;</span>).innerHTML = <span class="hljs-string">&quot;send get responseData from java, data = &quot;</span> + responseData<br>            &#125;<br>        );<br></code></pre></td></tr></table></figure><h4>源码解析</h4><p>从上面的使用中可以看到window.WebViewJavascriptBridge和bridge对象，window中好像没有这些对象？WebViewJavascriptBridge从哪里来？</p><p>答案在BridgeWebViewClient的onPageFinished中</p><p>onPageFinished中有这么一段代码</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">BridgeUtil</span>.</span></span>web<span class="hljs-constructor">ViewLoadLocalJs(<span class="hljs-params">view</span>, BridgeWebView.<span class="hljs-params">toLoadJs</span>)</span>;<br></code></pre></td></tr></table></figure><p>跟进BridgeUtil</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public static void web<span class="hljs-constructor">ViewLoadLocalJs(WebView <span class="hljs-params">view</span>, String <span class="hljs-params">path</span>)</span>&#123;<br>       String jsContent = asset<span class="hljs-constructor">File2Str(<span class="hljs-params">view</span>.<span class="hljs-params">getContext</span>()</span>, path);<br>       view.load<span class="hljs-constructor">Url(<span class="hljs-string">&quot;javascript:&quot;</span> + <span class="hljs-params">jsContent</span>)</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><p>h5页面加载完成之后执行assets下面的WebViewJavascriptBridge.js，然后将WebViewJavascriptBridge.js里面的一系列方法加入到window中。我们可以看WebViewJavascriptBridge.js中的代码。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dts">window.WebViewJavascriptBridge = &#123;<br><span class="hljs-symbol">        init:</span> init,<br><span class="hljs-symbol">        send:</span> send,<br><span class="hljs-symbol">        registerHandler:</span> registerHandler,<br><span class="hljs-symbol">        callHandler:</span> callHandler,<br><span class="hljs-symbol">        _fetchQueue:</span> _fetchQueue,<br><span class="hljs-symbol">        _handleMessageFromNative:</span> _handleMessageFromNative<br>    &#125;;<br></code></pre></td></tr></table></figure><p>这样WebViewJavascriptBridge对象就绑定到window中了。这是最重要的一步。接下来我们分两端来分析整个交互过程。</p><h4>native注册方法供h5调用</h4>注册方法<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">webView.register<span class="hljs-constructor">Handler(<span class="hljs-string">&quot;submitFromWeb&quot;</span>)</span> &#123; data, <span class="hljs-keyword">function</span> -&gt;<br>            <span class="hljs-keyword">function</span>.on<span class="hljs-constructor">CallBack(<span class="hljs-string">&quot;submitFromWeb exe, response data 中文 from Java&quot;</span>)</span><br>        &#125;<br></code></pre></td></tr></table></figure><p>跟进registerHandler函数</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, BridgeHandler&gt; messageHandlers = <span class="hljs-keyword">new</span> HashMap&lt;<span class="hljs-built_in">String</span>, BridgeHandler&gt;();<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">registerHandler</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> handlerName, BridgeHandler handler</span>)</span> &#123;<br><span class="hljs-keyword">if</span> (handler != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 添加至 Map&lt;String, BridgeHandler&gt;</span><br>messageHandlers.put(handlerName, handler);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将注册的方法添加到messageHandlers中，handlerName是方法的名字，BridgeHandler是个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BridgeHandler</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handler</span><span class="hljs-params">(String data, CallBackFunction function)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>用来回调h5传送的值和处理回传h5结果</p><p>h5端调用刚注册的submitFromWeb方法。趁热！！！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">window</span>.WebViewJavascriptBridge.callHandler(<br>                <span class="hljs-string">&#x27;submitFromWeb&#x27;</span><br>                , &#123;<span class="hljs-string">&#x27;param&#x27;</span>: <span class="hljs-string">&#x27;中文测试&#x27;</span>&#125;<br>                , <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">responseData</span>) </span>&#123;<br>                    <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;show&quot;</span>).innerHTML = <span class="hljs-string">&quot;send get responseData from java, data = &quot;</span> + responseData<br>                &#125;<br>            );<br></code></pre></td></tr></table></figure><p>跟进到WebViewJavascriptBridge.js中看callHandler</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-function"><span class="hljs-keyword">function</span></span> callHandler(handlerName, <span class="hljs-keyword">data</span>, responseCallback) &#123;<br>       _doSend(&#123;<br>           handlerName: handlerName,<br>           <span class="hljs-keyword">data</span>: <span class="hljs-keyword">data</span><br>       &#125;, responseCallback);<br>   &#125;<br></code></pre></td></tr></table></figure><p>跟进_doSend</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> CUSTOM_PROTOCOL_SCHEME = <span class="hljs-string">&#x27;yy&#x27;</span>;<br><span class="hljs-keyword">var</span> QUEUE_HAS_MESSAGE = <span class="hljs-string">&#x27;__QUEUE_MESSAGE__/&#x27;</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_doSend</span>(<span class="hljs-params">message, responseCallback</span>) </span>&#123;<br>        <span class="hljs-keyword">if</span> (responseCallback) &#123;<br>            <span class="hljs-keyword">var</span> callbackId = <span class="hljs-string">&#x27;cb_&#x27;</span> + (uniqueId++) + <span class="hljs-string">&#x27;_&#x27;</span> + <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime();<br>            responseCallbacks[callbackId] = responseCallback;<br>            message.callbackId = callbackId;<br>        &#125;<br><br>        sendMessageQueue.push(message);<br>        messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + <span class="hljs-string">&#x27;://&#x27;</span> + QUEUE_HAS_MESSAGE;<br>    &#125;<br></code></pre></td></tr></table></figure><p>分为有回调结果和没回调结果两种，有callback在message对象添加callbackId，然后将message对象添加到sendMessageQueue数组中，然后通过改变消息列表iframe的src触发shouldOverrideUrlLoading。消息列表iframe的创建代码也在WebViewJavascriptBridge.js中。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> <span class="hljs-constructor">_createQueueReadyIframe(<span class="hljs-params">doc</span>)</span> &#123;<br>        messagingIframe = doc.create<span class="hljs-constructor">Element(&#x27;<span class="hljs-params">iframe</span>&#x27;)</span>;<br>        messagingIframe.style.display = &#x27;none&#x27;;<br>        doc.documentElement.append<span class="hljs-constructor">Child(<span class="hljs-params">messagingIframe</span>)</span>;<br>    &#125;<br>    <br>var doc = document;<br><span class="hljs-constructor">_createQueueReadyIframe(<span class="hljs-params">doc</span>)</span>;<br></code></pre></td></tr></table></figure><p>接下来就看BridgeWebViewClient中shouldOverrideUrlLoading回调处理了。</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-built_in">String</span> YY_OVERRIDE_SCHEMA = <span class="hljs-string">&quot;yy://&quot;</span>;<br><span class="hljs-built_in">String</span> YY_RETURN_DATA = YY_OVERRIDE_SCHEMA + <span class="hljs-string">&quot;return/&quot;</span>;<br><br> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">url</span>.startsWith(BridgeUtil.YY_RETURN_DATA)) &#123; <span class="hljs-comment">// 如果是返回数据</span><br>                webView.handlerReturnData(<span class="hljs-built_in">url</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">url</span>.startsWith(BridgeUtil.YY_OVERRIDE_SCHEMA)) &#123; <br>                webView.flushMessageQueue();<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br></code></pre></td></tr></table></figure><p>第一个分支是处理返回数据，当前我们要看的是第二个分支，跟进flushMessageQueue代码。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript">重点关注<br><span class="hljs-built_in">String</span> JS_FETCH_QUEUE_FROM_JAVA = <span class="hljs-string">&quot;javascript:WebViewJavascriptBridge._fetchQueue();&quot;</span><br><br><span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">flushMessageQueue</span>(<span class="hljs-params"></span>)</span>&#123;<br> loadUrl(BridgeUtil.JS_FETCH_QUEUE_FROM_JAVA, <span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-title">CallBackFunction</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">//具体数据处理</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">loadUrl</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> jsUrl, CallBackFunction returnCallback</span>)</span> &#123;<br><span class="hljs-built_in">this</span>.loadUrl(jsUrl);<br>        <span class="hljs-comment">// 添加至 Map&lt;String, CallBackFunction&gt;</span><br>responseCallbacks.put(BridgeUtil.parseFunctionName(jsUrl), returnCallback);<br>&#125;<br></code></pre></td></tr></table></figure><p>第一步调用请求数据的js方法，第二步把回调处理添加到responseCallbacks Map中。</p><p>继续跟到WebViewJavascriptBridge.js中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> CUSTOM_PROTOCOL_SCHEME = <span class="hljs-string">&#x27;yy&#x27;</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_fetchQueue</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">var</span> messageQueueString = <span class="hljs-built_in">JSON</span>.stringify(sendMessageQueue);<br>        sendMessageQueue = [];<br>        <span class="hljs-keyword">if</span> (messageQueueString !== <span class="hljs-string">&#x27;[]&#x27;</span>) &#123;<br>            bizMessagingIframe.src = CUSTOM_PROTOCOL_SCHEME + <span class="hljs-string">&#x27;://return/_fetchQueue/&#x27;</span> + <span class="hljs-built_in">encodeURIComponent</span>(messageQueueString);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>序列化消息队列，改变消息体的iframe的src将消息体回调到BridgeWebViewClient的shouldOverrideUrlLoading中，消息体添加在url中。消息体的iframe创建与消息列表的类似。</p><p>继续跟到shouldOverrideUrlLoading中</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-built_in">String</span> YY_OVERRIDE_SCHEMA = <span class="hljs-string">&quot;yy://&quot;</span>;<br><span class="hljs-built_in">String</span> YY_RETURN_DATA = YY_OVERRIDE_SCHEMA + <span class="hljs-string">&quot;return/&quot;</span>;<br><br> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">url</span>.startsWith(BridgeUtil.YY_RETURN_DATA)) &#123; <span class="hljs-comment">// 如果是返回数据</span><br>            webView.handlerReturnData(<span class="hljs-built_in">url</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">url</span>.startsWith(BridgeUtil.YY_OVERRIDE_SCHEMA)) &#123;<br>            webView.flushMessageQueue();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br></code></pre></td></tr></table></figure><p>调用了handlerReturnData方法</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void handler<span class="hljs-constructor">ReturnData(String <span class="hljs-params">url</span>)</span> &#123;<br>String functionName = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">BridgeUtil</span>.</span></span>get<span class="hljs-constructor">FunctionFromReturnUrl(<span class="hljs-params">url</span>)</span>;<br>CallBackFunction f = responseCallbacks.get(functionName);<br>String data = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">BridgeUtil</span>.</span></span>get<span class="hljs-constructor">DataFromReturnUrl(<span class="hljs-params">url</span>)</span>;<br><span class="hljs-keyword">if</span> (f != null) &#123;<br>f.on<span class="hljs-constructor">CallBack(<span class="hljs-params">data</span>)</span>;<br>responseCallbacks.remove(functionName);<br>return;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从responseCallbacks中取出对应的回调处理数据，具体消息从url过滤中json对象解析得来。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span> (!<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TextUtils</span>.</span></span>is<span class="hljs-constructor">Empty(<span class="hljs-params">callbackId</span>)</span>) &#123;<br>        <span class="hljs-comment">//需要告诉h5端执行结果</span><br>responseFunction = <span class="hljs-keyword">new</span> <span class="hljs-constructor">CallBackFunction()</span> &#123;<br>@Override<br>public void on<span class="hljs-constructor">CallBack(String <span class="hljs-params">data</span>)</span> &#123;<br>Message responseMsg = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Message()</span>;<br>responseMsg.set<span class="hljs-constructor">ResponseId(<span class="hljs-params">callbackId</span>)</span>;<br>responseMsg.set<span class="hljs-constructor">ResponseData(<span class="hljs-params">data</span>)</span>;<br>queue<span class="hljs-constructor">Message(<span class="hljs-params">responseMsg</span>)</span>;<br>&#125;<br>&#125;;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    responseFunction = <span class="hljs-keyword">new</span> <span class="hljs-constructor">CallBackFunction()</span> &#123;<br>@Override<br>public void on<span class="hljs-constructor">CallBack(String <span class="hljs-params">data</span>)</span> &#123;<br><br> &#125;<br>  &#125;;<br>&#125;<br><br>BridgeHandler handler;<br><span class="hljs-keyword">if</span> (!<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TextUtils</span>.</span></span>is<span class="hljs-constructor">Empty(<span class="hljs-params">m</span>.<span class="hljs-params">getHandlerName</span>()</span>)) &#123;<br> handler = messageHandlers.get(m.get<span class="hljs-constructor">HandlerName()</span>);<br> &#125; <span class="hljs-keyword">else</span> &#123;<br>  handler = defaultHandler;<br> &#125;<br> <span class="hljs-keyword">if</span> (handler != null)&#123;<br>  handler.handler(m.get<span class="hljs-constructor">Data()</span>, responseFunction);<br>  &#125;<br></code></pre></td></tr></table></figure><p>分为需要告诉h5执行结果和不需要两种，不需要告诉的什么都不做就不需要说了。需要告诉的设置message中的responseId和data，执行queueMessage。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">queueMessage</span>(<span class="hljs-params">Message m</span>)</span> &#123;<br><span class="hljs-keyword">if</span> (startupMessage != <span class="hljs-literal">null</span>) &#123;<br>startupMessage.<span class="hljs-keyword">add</span>(m);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>dispatchMessage(m);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>startupMessage在onPageFinished中会置为null，具体的作用后面会讲到。这边会执行dispatchMessage方法。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">String JS_HANDLE_MESSAGE_FROM_JAVA = <span class="hljs-string">&quot;javascript:WebViewJavascriptBridge._handleMessageFromNative(&#x27;%s&#x27;);&quot;</span>;<br>void dispatch<span class="hljs-constructor">Message(Message <span class="hljs-params">m</span>)</span> &#123;<br>        String messageJson = m.<span class="hljs-keyword">to</span><span class="hljs-constructor">Json()</span>;<br>        <span class="hljs-comment">//字符串转义特殊字符</span><br><br>        String javascriptCommand = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span>format(BridgeUtil.JS_HANDLE_MESSAGE_FROM_JAVA, messageJson);<br>        <span class="hljs-comment">// 必须要找主线程才会将数据传递出去 --- 划重点</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span><span class="hljs-operator"> == </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Looper</span>.</span></span>get<span class="hljs-constructor">MainLooper()</span>.get<span class="hljs-constructor">Thread()</span>) &#123;<br>            this.load<span class="hljs-constructor">Url(<span class="hljs-params">javascriptCommand</span>)</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>又回到了WebViewJavascriptBridge.js的_handleMessageFromNative中，把结果塞回到html中。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> <span class="hljs-constructor">_handleMessageFromNative(<span class="hljs-params">messageJSON</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (receiveMessageQueue) &#123;<br>            receiveMessageQueue.push(messageJSON);<br>        &#125;<br>        <span class="hljs-constructor">_dispatchMessageFromNative(<span class="hljs-params">messageJSON</span>)</span>;<br>    &#125;<br>    <br><span class="hljs-keyword">function</span> <span class="hljs-constructor">_dispatchMessageFromNative(<span class="hljs-params">messageJSON</span>)</span> &#123;<br>     set<span class="hljs-constructor">Timeout(<span class="hljs-params">function</span>()</span> &#123;<br>        var message = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JSON</span>.</span></span>parse(messageJSON);<br>        var responseCallback;<br>        <span class="hljs-keyword">if</span> (message.responseId) &#123;<br>                responseCallback = responseCallbacks<span class="hljs-literal">[<span class="hljs-identifier">message</span>.<span class="hljs-identifier">responseId</span>]</span>;<br>                <span class="hljs-keyword">if</span> (!responseCallback) &#123;<br>                    return;<br>                &#125;<br>                response<span class="hljs-constructor">Callback(<span class="hljs-params">message</span>.<span class="hljs-params">responseData</span>)</span>;<br>                delete responseCallbacks<span class="hljs-literal">[<span class="hljs-identifier">message</span>.<span class="hljs-identifier">responseId</span>]</span>;<br>            &#125; <br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了看得更清楚我画了一张图</p><p><img src="https://user-gold-cdn.xitu.io/2019/10/18/16ddd795b9368bb7?w=1027&h=1298&f=png&s=62853"></p><h4>h5注册方法供native调用</h4><p>因为h5页面加载完成的时候WebViewJavascriptBridge对象还没有添加到window中，所以无法调用WebViewJavascriptBridge.registerHandler方法。这里有一个巧妙的做法。看下面的代码。</p><p>WebViewJavascriptBridge.js中创建了一个叫WebViewJavascriptBridgeReady自定义事件，加载到的时候立马执行。</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xquery">var<span class="hljs-built_in"> doc</span> =<span class="hljs-built_in"> document</span>;<br>var readyEvent =<span class="hljs-built_in"> doc</span>.createEvent(<span class="hljs-string">&#x27;Events&#x27;</span>);<br>readyEvent.initEvent(<span class="hljs-string">&#x27;WebViewJavascriptBridgeReady&#x27;</span>);<span class="hljs-built_in"></span><br><span class="hljs-built_in">doc</span>.dispatchEvent(readyEvent);<br></code></pre></td></tr></table></figure><p>html页面中添加了WebViewJavascriptBridgeReady事件的监听</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">connectWebViewJavascriptBridge</span>(<span class="hljs-params">callback</span>) </span>&#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.WebViewJavascriptBridge) &#123;<br>                callback(WebViewJavascriptBridge)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">document</span>.addEventListener(<br>                    <span class="hljs-string">&#x27;WebViewJavascriptBridgeReady&#x27;</span><br>                    , <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>                        callback(WebViewJavascriptBridge)<br>                    &#125;,<br>                    <span class="hljs-literal">false</span><br>                );<br>            &#125;<br>        &#125;<br><br>connectWebViewJavascriptBridge(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">bridge</span>) </span>&#123;<br>    bridge.registerHandler(<span class="hljs-string">&quot;functionInJs&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data, responseCallback</span>) </span>&#123;<br>            <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;show&quot;</span>).innerHTML = (<span class="hljs-string">&quot;data from Java: = &quot;</span> + data);<br>            <span class="hljs-keyword">if</span> (responseCallback) &#123;<br>                <span class="hljs-keyword">var</span> responseData = <span class="hljs-string">&quot;Javascript Says Right back aka!&quot;</span>;<br>                responseCallback(responseData);<br>                &#125;<br>            &#125;);<br>&#125;)<br></code></pre></td></tr></table></figure><p>也就是说增加了一个钩子，WebViewJavascriptBridge.js执行完成就能通知到html，随后就可以注册事件了，这边注册了一个叫functionInJs的事件。</p><p>native调用该方法</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">webView.call<span class="hljs-constructor">Handler(<span class="hljs-string">&quot;functionInJs&quot;</span>, Gson()</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">Json(<span class="hljs-params">user</span>)</span>) &#123; data -&gt;<br>           <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Log</span>.</span></span>e(<span class="hljs-string">&quot;处理结果&quot;</span>, data)<br>   &#125;<br></code></pre></td></tr></table></figure><p>跟进BridgeWebview的callHandler方法</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public void call<span class="hljs-constructor">Handler(String <span class="hljs-params">handlerName</span>, String <span class="hljs-params">data</span>, CallBackFunction <span class="hljs-params">callBack</span>)</span> &#123;<br>        <span class="hljs-keyword">do</span><span class="hljs-constructor">Send(<span class="hljs-params">handlerName</span>, <span class="hljs-params">data</span>, <span class="hljs-params">callBack</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>跟进doSend</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> void <span class="hljs-keyword">do</span><span class="hljs-constructor">Send(String <span class="hljs-params">handlerName</span>, String <span class="hljs-params">data</span>, CallBackFunction <span class="hljs-params">responseCallback</span>)</span> &#123;<br>Message m = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Message()</span>;<br><span class="hljs-keyword">if</span> (!<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TextUtils</span>.</span></span>is<span class="hljs-constructor">Empty(<span class="hljs-params">data</span>)</span>) &#123;<br>m.set<span class="hljs-constructor">Data(<span class="hljs-params">data</span>)</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (responseCallback != null) &#123;<br>String callbackStr = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span>format(BridgeUtil.CALLBACK_ID_FORMAT, ++uniqueId + (BridgeUtil.UNDERLINE_STR + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SystemClock</span>.</span></span>current<span class="hljs-constructor">ThreadTimeMillis()</span>));<br>responseCallbacks.put(callbackStr, responseCallback);<br>m.set<span class="hljs-constructor">CallbackId(<span class="hljs-params">callbackStr</span>)</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (!<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TextUtils</span>.</span></span>is<span class="hljs-constructor">Empty(<span class="hljs-params">handlerName</span>)</span>) &#123;<br>  m.set<span class="hljs-constructor">HandlerName(<span class="hljs-params">handlerName</span>)</span>;<br>&#125;<br>queue<span class="hljs-constructor">Message(<span class="hljs-params">m</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>组装Message，有responseCallback把responseCallback添加到responseCallbacks</p><p>跟进queueMessage</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">queueMessage</span>(<span class="hljs-params">Message m</span>)</span> &#123;<br><span class="hljs-keyword">if</span> (startupMessage != <span class="hljs-literal">null</span>) &#123;<br>   startupMessage.<span class="hljs-keyword">add</span>(m);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>   dispatchMessage(m);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这边又看到了startupMessage，startupMessage就是在这里用的。这边startupMessage不为null，把消息添加到了startupMessage中。执行是在onPageFinished中。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span> (webView.get<span class="hljs-constructor">StartupMessage()</span> != null) &#123;<br>            <span class="hljs-keyword">for</span> (Message m : webView.get<span class="hljs-constructor">StartupMessage()</span>) &#123;<br>                webView.dispatch<span class="hljs-constructor">Message(<span class="hljs-params">m</span>)</span>;<br>            &#125;<br>            webView.set<span class="hljs-constructor">StartupMessage(<span class="hljs-params">null</span>)</span>;<br>        &#125;<br></code></pre></td></tr></table></figure><p>走到了dispatchMessage</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">String JS_HANDLE_MESSAGE_FROM_JAVA = <span class="hljs-string">&quot;javascript:WebViewJavascriptBridge._handleMessageFromNative(&#x27;%s&#x27;);&quot;</span>;<br>void dispatch<span class="hljs-constructor">Message(Message <span class="hljs-params">m</span>)</span> &#123;<br>        String messageJson = m.<span class="hljs-keyword">to</span><span class="hljs-constructor">Json()</span>;<br>        <span class="hljs-comment">//字符串转义特殊字符</span><br><br>        String javascriptCommand = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span>format(BridgeUtil.JS_HANDLE_MESSAGE_FROM_JAVA, messageJson);<br>        <span class="hljs-comment">// 必须要找主线程才会将数据传递出去 --- 划重点</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span><span class="hljs-operator"> == </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Looper</span>.</span></span>get<span class="hljs-constructor">MainLooper()</span>.get<span class="hljs-constructor">Thread()</span>) &#123;<br>            this.load<span class="hljs-constructor">Url(<span class="hljs-params">javascriptCommand</span>)</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>跟进WebViewJavascriptBridge.js的_handleMessageFromNative</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> <span class="hljs-constructor">_handleMessageFromNative(<span class="hljs-params">messageJSON</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (receiveMessageQueue) &#123;<br>            receiveMessageQueue.push(messageJSON);<br>        &#125;<br>        <span class="hljs-constructor">_dispatchMessageFromNative(<span class="hljs-params">messageJSON</span>)</span>;<br>       <br>    &#125;<br></code></pre></td></tr></table></figure><p>走到_dispatchMessageFromNative</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_dispatchMessageFromNative</span>(<span class="hljs-params">messageJSON</span>) </span>&#123;<br>     <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>       <span class="hljs-keyword">var</span> message = <span class="hljs-built_in">JSON</span>.parse(messageJSON);<br>       <span class="hljs-keyword">if</span> (message.callbackId) &#123;<br>            <span class="hljs-keyword">var</span> callbackResponseId = message.callbackId;<br>            responseCallback = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">responseData</span>) </span>&#123;<br>                 _doSend(&#123;<br>                    <span class="hljs-attr">responseId</span>: callbackResponseId,<br>                    <span class="hljs-attr">responseData</span>: responseData<br>                &#125;);<br>                &#125;;<br>            &#125;<br>          <span class="hljs-keyword">var</span> handler = WebViewJavascriptBridge._messageHandler;<br>                <span class="hljs-keyword">if</span> (message.handlerName) &#123;<br>                    handler = messageHandlers[message.handlerName];<br>                &#125;<br>           <span class="hljs-keyword">try</span> &#123;<br>                handler(message.data, responseCallback);<br>                &#125; <span class="hljs-keyword">catch</span> (exception) &#123;<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">console</span> != <span class="hljs-string">&#x27;undefined&#x27;</span>) &#123;<br>                        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;WebViewJavascriptBridge: WARNING: javascript handler threw.&quot;</span>, message, exception);<br>                &#125;<br>            &#125;<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有回调的情况组装responseCallback，从messageHandlers找到对应的handler处理数据。回调数据在_doSend中发送</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> CUSTOM_PROTOCOL_SCHEME = <span class="hljs-string">&#x27;yy&#x27;</span>;<br>    <span class="hljs-keyword">var</span> QUEUE_HAS_MESSAGE = <span class="hljs-string">&#x27;__QUEUE_MESSAGE__/&#x27;</span>;<br>    <br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_doSend</span>(<span class="hljs-params">message, responseCallback</span>) </span>&#123;<br>        <span class="hljs-keyword">if</span> (responseCallback) &#123;<br>            <span class="hljs-keyword">var</span> callbackId = <span class="hljs-string">&#x27;cb_&#x27;</span> + (uniqueId++) + <span class="hljs-string">&#x27;_&#x27;</span> + <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime();<br>            responseCallbacks[callbackId] = responseCallback;<br>            message.callbackId = callbackId;<br>        &#125;<br><br>        sendMessageQueue.push(message);<br>        messagingIframe.src = CUSTOM_PROTOCOL_SCHEME + <span class="hljs-string">&#x27;://&#x27;</span> + QUEUE_HAS_MESSAGE;<br>    &#125;<br></code></pre></td></tr></table></figure><p>改变消息体iframe的src，将回调数据返回到shouldOverrideUrlLoading中</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">void handler<span class="hljs-constructor">ReturnData(String <span class="hljs-params">url</span>)</span> &#123;<br>String functionName = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">BridgeUtil</span>.</span></span>get<span class="hljs-constructor">FunctionFromReturnUrl(<span class="hljs-params">url</span>)</span>;<br>CallBackFunction f = responseCallbacks.get(functionName);<br>String data = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">BridgeUtil</span>.</span></span>get<span class="hljs-constructor">DataFromReturnUrl(<span class="hljs-params">url</span>)</span>;<br><span class="hljs-keyword">if</span> (f != null) &#123;<br>   f.on<span class="hljs-constructor">CallBack(<span class="hljs-params">data</span>)</span>;<br>   responseCallbacks.remove(functionName);<br>   return;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从responseCallbacks拿到对应的CallBackFunction回调数据，至此回调结果页拿到了。</p><p><img src="https://user-gold-cdn.xitu.io/2019/10/18/16dddc0b210d3afe?w=1010&h=1533&f=png&s=75215"></p><h4>其他</h4><p>1.添加默认处理</br></p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">init</span><span class="hljs-params">(messageHandler)</span> </span>&#123;<br>       WebViewJavascriptBridge._messageHandler = messageHandler;<br>   &#125;<br>   <br>    bridge.init(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(message, responseCallback)</span> </span>&#123;<br>               <span class="hljs-keyword">var</span> data = &#123;<br>                   <span class="hljs-string">&#x27;Javascript Responds&#x27;</span>: <span class="hljs-string">&#x27;测试中文!&#x27;</span><br>               &#125;;<br><br>               <span class="hljs-keyword">if</span> (responseCallback) &#123;<br>                   responseCallback(data);<br>               &#125;<br>       &#125;);<br></code></pre></td></tr></table></figure><p>2._dispatchMessageFromNative为什么要异步执行</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">为了两条数据消息不重叠，导致消息丢失。<br></code></pre></td></tr></table></figure><h4>总结</h4>h5发送数据给native通过改变iframe的src回调到shouldOverrideUrlLoading</br>native发送消息给h5通过loadurl]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jsbridge</tag>
      
      <tag>webview</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ARouter路由跳转到底是怎么实现的？</title>
    <link href="/2021/07/07/arouter/"/>
    <url>/2021/07/07/arouter/</url>
    
    <content type="html"><![CDATA[<h4>前言</h4><p>相信绝大多数公司的项目都做了组件化。为了解耦，组件化势必要解决<strong>组件间的通信</strong>。其中阿里巴巴开源的Arouter很好的解决了组件间的通信，一直受到开发者的青睐。今天，我们来一步步揭开它的神秘面纱。</p><h4>首先下载源代码，项目地址：<br></h4><p><a href="https://github.com/alibaba/ARouter">https://github.com/alibaba/ARouter</a></p><h4>来讲一下项目结构：</h4><p><img src="https://user-gold-cdn.xitu.io/2019/11/12/16e5e8e3486c4a3f?w=462&h=474&f=png&s=53929"></p><ul><li>app:项目主工程，演示代码</li><li>module-java：java演示代码</li><li>module-kotlin：kotlin演示代码</li><li>arouter-annotation：所有注解以及注解涉及到的类</li><li>arouter-compiler：注解处理器，APT</li><li>arouter-gradle-plugin：路由表自动注册插件</li><li>arouter-idea-plugin：路由导航插件，搜索ARouter Helper插件安装即可</li><li>arouter-api：所有的api，关键代码基本上在这边</li></ul><h4>第一步就是要生成注解类</h4>@Route @Autowired Interceptor Provider都会生成如下面所示的对应注解类，java生成的注解类的位置在build-generated-sourse-apt中，kotlin生成的注解类的位置在build-generated-sourse-kapt<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> ARouter?Group?app implements IRouteGroup &#123;<br>  @Override<br>  public void load<span class="hljs-constructor">Into(Map&lt;String, RouteMeta&gt; <span class="hljs-params">atlas</span>)</span> &#123;<br>    atlas.put(<span class="hljs-string">&quot;/app/degrade1&quot;</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">RouteMeta</span>.</span></span>build(RouteType.PROVIDER, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DegradeServiceImpl</span>.</span></span><span class="hljs-keyword">class</span>, <span class="hljs-string">&quot;/app/degrade1&quot;</span>, <span class="hljs-string">&quot;app&quot;</span>, null, -<span class="hljs-number">1</span>, -<span class="hljs-number">2147483648</span>));<br>    atlas.put(<span class="hljs-string">&quot;/app/main&quot;</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">RouteMeta</span>.</span></span>build(RouteType.ACTIVITY, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">MainActivity</span>.</span></span><span class="hljs-keyword">class</span>, <span class="hljs-string">&quot;/app/main&quot;</span>, <span class="hljs-string">&quot;app&quot;</span>, null, -<span class="hljs-number">1</span>, -<span class="hljs-number">2147483648</span>));<br>    atlas.put(<span class="hljs-string">&quot;/app/path&quot;</span>, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">RouteMeta</span>.</span></span>build(RouteType.PROVIDER, <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">PathReplaceServiceImpl</span>.</span></span><span class="hljs-keyword">class</span>, <span class="hljs-string">&quot;/app/path&quot;</span>, <span class="hljs-string">&quot;app&quot;</span>, null, -<span class="hljs-number">1</span>, -<span class="hljs-number">2147483648</span>));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里需要重点关注一下RouteMeta这个类，这个类存储了目标对象的所有信息。包括路由类型、目标对象类、path、group、参数、优先级、额外参数。<br></p><p>涉及到的知识点:</p><ul><li>1.注解，注解生成器apt</li><li>2.javapoet</li><li>3.auto-service</li></ul><p>这里是我写的一个AptDemo，仅供参考：<br></p><p><a href="https://github.com/liulingfeng/APT">https://github.com/liulingfeng/APT</a></p><p>关于AbstractProcessor的<strong>process多次执行</strong>可以通过下面方法处理</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> <span class="hljs-function"><span class="hljs-title">process</span>(<span class="hljs-params"><span class="hljs-built_in">Set</span>&lt;? <span class="hljs-keyword">extends</span> TypeElement&gt; annotations, RoundEnvironment roundEnvironment</span>)</span> &#123;<br>       <span class="hljs-keyword">if</span> (annotations != <span class="hljs-literal">null</span> &amp;&amp; annotations.size() &gt; <span class="hljs-number">0</span>) &#123;<br>          <br>       &#125;<br>   &#125;<br><br></code></pre></td></tr></table></figure><h4>下面正式讲解api</h4>先整体感受一下整个流程<br><p><img src="https://user-gold-cdn.xitu.io/2019/11/20/16e88ab7c09ec391?w=1088&h=1287&f=png&s=117461"><br>根据官方说明，首先在Application中调用如下api</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span>(BuildConfig.DEBUG)&#123;<br>           <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ARouter</span>.</span></span><span class="hljs-keyword">open</span><span class="hljs-constructor">Log()</span>;<span class="hljs-comment">//打开日志</span><br>           <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ARouter</span>.</span></span><span class="hljs-keyword">open</span><span class="hljs-constructor">Debug()</span>;<span class="hljs-comment">//打开路由调试</span><br>       &#125;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ARouter</span>.</span></span>init(this);<br></code></pre></td></tr></table></figure><p>进入Arouter.init(this)</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public static void init(Application application) &#123;<br>        <span class="hljs-keyword">if</span> (!hasInit) &#123;<br>            logger = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">_ARouter</span>.</span></span>logger;<br>            hasInit = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">_ARouter</span>.</span></span>init(application);<br><br>            <span class="hljs-keyword">if</span> (hasInit) &#123;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">_ARouter</span>.</span></span>after<span class="hljs-constructor">Init()</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>hasInit保证只初始化一次，内部调用了_ARouter.init(application)，Arouter是门面， _Arouter是具体实现，典型的门面模式。初始化之后调用 _ARouter.afterInit初始化拦截器（这个后面细讲）。继续跟进 _ARouter.init</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">init</span><span class="hljs-params">(Application application)</span> </span>&#123;<br>        mContext = application;<br>        LogisticsCenter.init(mContext, executor);<br>        logger.info(Consts.TAG, <span class="hljs-string">&quot;ARouter init success!&quot;</span>);<br>        hasInit = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>一眼就看到关键代码在LogisticsCenter.init中，executor是一个自定义的线程池(实现了一种抛出错误的方式)。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public synchronized static void init(Context context, ThreadPoolExecutor tpe) throws HandlerException &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (registerByPlugin) &#123;<br>                logger.info(TAG, <span class="hljs-string">&quot;Load router map by arouter-auto-register plugin.&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                Set&lt;String&gt; routerMap;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ARouter</span>.</span></span>debuggable<span class="hljs-literal">()</span><span class="hljs-operator"> || </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">PackageUtils</span>.</span></span>is<span class="hljs-constructor">NewVersion(<span class="hljs-params">context</span>)</span>) &#123;<br>                    routerMap = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ClassUtils</span>.</span></span>get<span class="hljs-constructor">FileNameByPackageName(<span class="hljs-params">mContext</span>, ROUTE_ROOT_PAKCAGE)</span>;<br>                    <span class="hljs-keyword">if</span> (!routerMap.is<span class="hljs-constructor">Empty()</span>) &#123;<br>                        context.get<span class="hljs-constructor">SharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE)</span>.edit<span class="hljs-literal">()</span>.put<span class="hljs-constructor">StringSet(AROUTER_SP_KEY_MAP, <span class="hljs-params">routerMap</span>)</span>.apply<span class="hljs-literal">()</span>;<br>                    &#125;<br><br>                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">PackageUtils</span>.</span></span>update<span class="hljs-constructor">Version(<span class="hljs-params">context</span>)</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">for</span> (String className : routerMap) &#123;<br>                    <span class="hljs-keyword">if</span> (className.starts<span class="hljs-constructor">With(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_ROOT)</span>) &#123;<br>                        ((IRouteRoot) (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Class</span>.</span></span><span class="hljs-keyword">for</span><span class="hljs-constructor">Name(<span class="hljs-params">className</span>)</span>.get<span class="hljs-constructor">Constructor()</span>.<span class="hljs-keyword">new</span><span class="hljs-constructor">Instance()</span>)).load<span class="hljs-constructor">Into(Warehouse.<span class="hljs-params">groupsIndex</span>)</span>;<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (className.starts<span class="hljs-constructor">With(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_INTERCEPTORS)</span>) &#123;<br>                        ((IInterceptorGroup) (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Class</span>.</span></span><span class="hljs-keyword">for</span><span class="hljs-constructor">Name(<span class="hljs-params">className</span>)</span>.get<span class="hljs-constructor">Constructor()</span>.<span class="hljs-keyword">new</span><span class="hljs-constructor">Instance()</span>)).load<span class="hljs-constructor">Into(Warehouse.<span class="hljs-params">interceptorsIndex</span>)</span>;<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (className.starts<span class="hljs-constructor">With(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_PROVIDERS)</span>) &#123;<br>                        ((IProviderGroup) (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Class</span>.</span></span><span class="hljs-keyword">for</span><span class="hljs-constructor">Name(<span class="hljs-params">className</span>)</span>.get<span class="hljs-constructor">Constructor()</span>.<span class="hljs-keyword">new</span><span class="hljs-constructor">Instance()</span>)).load<span class="hljs-constructor">Into(Warehouse.<span class="hljs-params">providersIndex</span>)</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125; catch (Exception e) &#123;<br>            throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">HandlerException(TAG + <span class="hljs-string">&quot;ARouter init logistics center exception! [&quot;</span> + <span class="hljs-params">e</span>.<span class="hljs-params">getMessage</span>()</span> + <span class="hljs-string">&quot;]&quot;</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>代码比较长，我把它分解一下</p><ul><li>1.判断是不是用插件自动注册路由表，插件注册的方式另说</li><li>2.从dex中加载指定路径（com.alibaba.android.arouter.routes）下的所有类的名字，其实就是注解生成类，然后根据版本号升级版本。非debuggable环境下从SharedPreferences缓存中读取（做的一个优化点）</li><li>3.反射调用loadInto把Group、Interceptor、Provider的映射关系添加到集合中</li></ul><p>看一下各种类型的注解生成类<br><br>Root(这里做了优化先<strong>加载各个group</strong>，用到的时候再加载各个group下的路由)</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ARouter</span>?<span class="hljs-title">Root</span>?<span class="hljs-title">app</span> <span class="hljs-title">implements</span> <span class="hljs-title">IRouteRoot</span> </span>&#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">loadInto</span>(<span class="hljs-params"><span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, Class&lt;? <span class="hljs-keyword">extends</span> IRouteGroup&gt;&gt; routes</span>)</span> &#123;<br>    routes.put(<span class="hljs-string">&quot;app&quot;</span>, ARouter?Group?app.class);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Interceptor</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">ARouter</span>?<span class="hljs-symbol">Interceptors</span>?<span class="hljs-symbol">app</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">IInterceptorGroup</span> &#123;<br>  @Override<br>  <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> loadInto(Map&lt;Integer, Class&lt;? extends IInterceptor&gt;&gt; <span class="hljs-built_in">int</span>erceptors) &#123;<br>    <span class="hljs-built_in">int</span>erceptors.put(<span class="hljs-number">9</span>, TestInterceptor2.class);<br>    <span class="hljs-built_in">int</span>erceptors.put(<span class="hljs-number">10</span>, TestInterceptor.class);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Provider</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ARouter</span>?<span class="hljs-title">Providers</span>?<span class="hljs-title">app</span> <span class="hljs-title">implements</span> <span class="hljs-title">IProviderGroup</span> </span>&#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">loadInto</span>(<span class="hljs-params"><span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, RouteMeta&gt; providers</span>)</span> &#123;<br>    providers.put(<span class="hljs-string">&quot;com.xls.HelloService&quot;</span>, RouteMeta.build(RouteType.PROVIDER, HelloServiceImpl.class, <span class="hljs-string">&quot;/yourservicegroupname/hello&quot;</span>, <span class="hljs-string">&quot;yourservicegroupname&quot;</span>, <span class="hljs-literal">null</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">2147483648</span>));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>init工作总结及知识点</p><ul><li>1.把Group、Interceptor、Provider注解类的映射添加到Warehouse.groupsIndex、Warehouse.interceptorsIndex、Warehouse.providersIndex集合中</li><li>2.实例化所有的Interceptor添加到Warehouse.interceptors中</li><li>3.dex分析-多dex怎么查找-热修复的根本原理是什么</li><li>4.线程池-线程池各个参数-线程池抛出错误的方法-如何保证线程池线程名字唯一性-原子类</li></ul><h4>顺便补充一下插件自动注册路由表</h4>首先目光移到PluginLaunch，这是自定义插件的入口。<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> PluginLaunch <span class="hljs-keyword">implements</span> Plugin&lt;<span class="hljs-keyword">Project</span>&gt; &#123;<br>    @Override<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> apply(<span class="hljs-keyword">Project</span> <span class="hljs-keyword">project</span>) &#123;<br>            <span class="hljs-keyword">def</span> android = <span class="hljs-keyword">project</span>.extensions.getByType(AppExtension)<br>            <span class="hljs-keyword">def</span> transformImpl = <span class="hljs-keyword">new</span> RegisterTransform(<span class="hljs-keyword">project</span>)<br><br>            ArrayList&lt;ScanSetting&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<span class="hljs-number">3</span>)<br>            list.add(<span class="hljs-keyword">new</span> ScanSetting(<span class="hljs-string">&#x27;IRouteRoot&#x27;</span>))<br>            list.add(<span class="hljs-keyword">new</span> ScanSetting(<span class="hljs-string">&#x27;IInterceptorGroup&#x27;</span>))<br>            list.add(<span class="hljs-keyword">new</span> ScanSetting(<span class="hljs-string">&#x27;IProviderGroup&#x27;</span>))<br>            RegisterTransform.registerList = list<br>            android.registerTransform(transformImpl)<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里完成了自定义Transform的注册以及添加需要过滤的接口到ScanSetting，最主要的代码自然是在RegisterTransform中。直奔RegisterTransform的transform方法，首先遍历jar。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">inputs.each &#123; TransformInput input -&gt;<br>        input.jarInputs.each &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ScanUtil</span>.</span></span>should<span class="hljs-constructor">ProcessPreDexJar(<span class="hljs-params">src</span>.<span class="hljs-params">absolutePath</span>)</span>) &#123;<br>                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ScanUtil</span>.</span></span>scan<span class="hljs-constructor">Jar(<span class="hljs-params">src</span>, <span class="hljs-params">dest</span>)</span><br>                &#125;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">FileUtils</span>.</span></span>copy<span class="hljs-constructor">File(<span class="hljs-params">src</span>, <span class="hljs-params">dest</span>)</span><br>            &#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">static void scan<span class="hljs-constructor">Jar(File <span class="hljs-params">jarFile</span>, File <span class="hljs-params">destFile</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (jarFile) &#123;<br>            def file = <span class="hljs-keyword">new</span> <span class="hljs-constructor">JarFile(<span class="hljs-params">jarFile</span>)</span><br>            Enumeration enumeration = file.entries<span class="hljs-literal">()</span><br>            <span class="hljs-keyword">while</span> (enumeration.has<span class="hljs-constructor">MoreElements()</span>) &#123;<br>                JarEntry jarEntry = (JarEntry) enumeration.next<span class="hljs-constructor">Element()</span><br>                String entryName = jarEntry.get<span class="hljs-constructor">Name()</span><br>                <span class="hljs-keyword">if</span> (entryName.starts<span class="hljs-constructor">With(<span class="hljs-string">&quot;com/alibaba/android/arouter/routes/&quot;</span>)</span>) &#123;<br>                    InputStream inputStream = file.get<span class="hljs-constructor">InputStream(<span class="hljs-params">jarEntry</span>)</span><br>                    scan<span class="hljs-constructor">Class(<span class="hljs-params">inputStream</span>)</span><br>                    inputStream.close<span class="hljs-literal">()</span><br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;com/alibaba/android/arouter/core/LogisticsCenter.class&quot;</span><span class="hljs-operator"> == </span>entryName) &#123;<br>                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">RegisterTransform</span>.</span></span>fileContainsInitClass = destFile<br>                &#125;<br>            &#125;<br>            file.close<span class="hljs-literal">()</span><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>做到两步工作:1.把com/alibaba/android/arouter/routes包名下的交给scanClass处理（这个稍后会分析到） 2.找到LogisticsCenter.class类，对于这个类想必很熟悉吧。</p><p>接下来遍历directory</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">input.directoryInputs.each &#123; DirectoryInput directoryInput -&gt;<br>               directoryInput.file.eachFileRecurse &#123; File file -&gt;<br>                   <span class="hljs-keyword">if</span>(file.is<span class="hljs-constructor">File()</span><span class="hljs-operator"> &amp;&amp; </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ScanUtil</span>.</span></span>should<span class="hljs-constructor">ProcessClass(<span class="hljs-params">path</span>)</span>)&#123;<br>                       <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ScanUtil</span>.</span></span>scan<span class="hljs-constructor">Class(<span class="hljs-params">file</span>)</span><br>                   &#125;<br>               &#125;<br>           &#125;<br></code></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">static void scan<span class="hljs-constructor">Class(InputStream <span class="hljs-params">inputStream</span>)</span> &#123;<br>        ClassReader cr = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ClassReader(<span class="hljs-params">inputStream</span>)</span><br>        ClassWriter cw = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ClassWriter(<span class="hljs-params">cr</span>, 0)</span><br>        ScanClassVisitor cv = <span class="hljs-keyword">new</span> <span class="hljs-constructor">ScanClassVisitor(Opcodes.ASM5, <span class="hljs-params">cw</span>)</span><br>        cr.accept(cv, ClassReader.EXPAND_FRAMES)<br>        inputStream.close<span class="hljs-literal">()</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>把文件流丢给ScanClassVisitor</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">static <span class="hljs-keyword">class</span> <span class="hljs-symbol">ScanClassVisitor</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">ClassVisitor</span> &#123;<br><br>       ScanClassVisitor(<span class="hljs-built_in">int</span> api, ClassVisitor cv) &#123;<br>           <span class="hljs-keyword">super</span>(api, cv)<br>       &#125;<br><br>       <span class="hljs-built_in">void</span> visit(<span class="hljs-built_in">int</span> version, <span class="hljs-built_in">int</span> access, String name, String signature,<br>                  String superName, String[] <span class="hljs-built_in">int</span>erfaces) &#123;<br>           <span class="hljs-keyword">super</span>.visit(version, access, name, signature, superName, <span class="hljs-built_in">int</span>erfaces)<br>           RegisterTransform.registerList.each &#123; ext -&gt;<br>               <span class="hljs-keyword">if</span> (ext.<span class="hljs-built_in">int</span>erfaceName &amp;&amp; <span class="hljs-built_in">int</span>erfaces != <span class="hljs-literal">null</span>) &#123;<br>                   <span class="hljs-built_in">int</span>erfaces.each &#123; itName -&gt;<br>                       <span class="hljs-keyword">if</span> (itName == ext.<span class="hljs-built_in">int</span>erfaceName) &#123;<br>                           ext.classList.add(name)<br>                       &#125;<br>                   &#125;<br>               &#125;<br>           &#125;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>一看就明白，就是把<strong>所有实现了IRouteRoot、IInterceptorGroup、IProviderGroup接口的类存到集合中</strong>。</p><p>接着看最后一步做了什么</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span> (fileContainsInitClass) &#123;<br>            registerList.each &#123; ext -&gt;<br>                <span class="hljs-keyword">if</span> (ext.classList.is<span class="hljs-constructor">Empty()</span>) &#123;<br>                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Logger</span>.</span></span>e(<span class="hljs-string">&quot;No class implements found for interface:&quot;</span> + ext.interfaceName)<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">RegisterCodeGenerator</span>.</span></span>insert<span class="hljs-constructor">InitCodeTo(<span class="hljs-params">ext</span>)</span><br>                &#125;<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><p>关键代码都在RegisterCodeGenerator这个类中，我只列关键代码。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">private</span> byte[] referHackWhenInit(InputStream inputStream) &#123;<br>        ClassReader cr = <span class="hljs-keyword">new</span> <span class="hljs-type">ClassReader</span>(inputStream)<br>        ClassWriter cw = <span class="hljs-keyword">new</span> <span class="hljs-type">ClassWriter</span>(cr, <span class="hljs-number">0</span>)<br>        ClassVisitor cv = <span class="hljs-keyword">new</span> <span class="hljs-type">MyClassVisitor</span>(Opcodes.ASM5, cw)<br>        cr.accept(cv, ClassReader.EXPAND_FRAMES)<br>        <span class="hljs-keyword">return</span> cw.toByteArray()<br>    &#125;<br>    <br>MethodVisitor visitMethod(int access, <span class="hljs-keyword">String</span> name, <span class="hljs-keyword">String</span> desc,<br>                                  <span class="hljs-keyword">String</span> signature, <span class="hljs-keyword">String</span>[] exceptions) &#123;<br>            MethodVisitor mv = <span class="hljs-keyword">super</span>.visitMethod(access, name, desc, signature, exceptions)<br>            <span class="hljs-keyword">if</span> (name == <span class="hljs-string">&quot;loadRouterMap&quot;</span>) &#123;<br>                mv = <span class="hljs-keyword">new</span> <span class="hljs-type">RouteMethodVisitor</span>(Opcodes.ASM5, mv)<br>            &#125;<br>            <span class="hljs-keyword">return</span> mv<br>        &#125;<br></code></pre></td></tr></table></figure><p>找到hook点loadRouterMap。hook点的设计特别巧妙，增强了代码的可读性。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">void</span> visitInsn(<span class="hljs-type">int</span> opcode) &#123;<br>            <span class="hljs-keyword">if</span> ((opcode &gt;= Opcodes.IRETURN &amp;&amp; opcode &lt;= Opcodes.<span class="hljs-keyword">RETURN</span>)) &#123;<br>                <span class="hljs-keyword">extension</span>.classList.<span class="hljs-keyword">each</span> &#123; <span class="hljs-type">name</span> -&gt;<br>                    mv.visitMethodInsn(Opcodes.INVOKESTATIC<br>                            , &quot;com/alibaba/android/arouter/core/LogisticsCenter&quot;<br>                            , &quot;register&quot;<br>                            , &quot;(Ljava/lang/String;)V&quot;<br>                            , <span class="hljs-keyword">false</span>)<br>                &#125;<br>            &#125;<br>            super.visitInsn(opcode)<br>        &#125;<br></code></pre></td></tr></table></figure><p>调用LogisticsCenter的register方法，我们来看一下register方法做了什么。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> static void register(String className) &#123;<br>       <span class="hljs-keyword">if</span> (!<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TextUtils</span>.</span></span>is<span class="hljs-constructor">Empty(<span class="hljs-params">className</span>)</span>) &#123;<br>           <span class="hljs-keyword">try</span> &#123;<br>               Class&lt;?&gt; clazz = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Class</span>.</span></span><span class="hljs-keyword">for</span><span class="hljs-constructor">Name(<span class="hljs-params">className</span>)</span>;<br>               Object obj = clazz.get<span class="hljs-constructor">Constructor()</span>.<span class="hljs-keyword">new</span><span class="hljs-constructor">Instance()</span>;<br>               <span class="hljs-keyword">if</span> (obj instanceof IRouteRoot) &#123;<br>                   register<span class="hljs-constructor">RouteRoot((IRouteRoot)</span> obj);<br>               &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (obj instanceof IProviderGroup) &#123;<br>                   register<span class="hljs-constructor">Provider((IProviderGroup)</span> obj);<br>               &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (obj instanceof IInterceptorGroup) &#123;<br>                   register<span class="hljs-constructor">Interceptor((IInterceptorGroup)</span> obj);<br>               &#125; <span class="hljs-keyword">else</span> &#123;<br>                   logger.info(TAG, <span class="hljs-string">&quot;register failed, class name: &quot;</span> + className<br>                           + <span class="hljs-string">&quot; should implements one of IRouteRoot/IProviderGroup/IInterceptorGroup.&quot;</span>);<br>               &#125;<br>           &#125; catch (Exception e) &#123;<br>               logger.error(TAG,<span class="hljs-string">&quot;register class error:&quot;</span> + className);<br>           &#125;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>所有实现了IRouteRoot、IInterceptorGroup、IProviderGroup接口的类都加入了Warehouse相对应的集合中。至此自动注册工作完成。</p><p>插件注册涉及知识点</p><ul><li>1.自定义plugin、ASM</li></ul><h4>路由跳转</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ARouter</span>.</span></span>get<span class="hljs-constructor">Instance()</span>.build(<span class="hljs-string">&quot;/home/test&quot;</span>).<span class="hljs-keyword">with</span><span class="hljs-constructor">String(<span class="hljs-string">&quot;key3&quot;</span>, <span class="hljs-string">&quot;888&quot;</span>)</span><br>                    .<span class="hljs-keyword">with</span><span class="hljs-constructor">Long(<span class="hljs-string">&quot;key1&quot;</span>, 666L)</span><br>                    .navigation(this)<br></code></pre></td></tr></table></figure><p>先看build，new一个Postcard对象并给Postcard设置path和group。Postcard构造方法中new了一个bundler对象。PathReplaceService提供了动态改path的方式，后面细讲。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">protected Postcard build(String path, String group) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TextUtils</span>.</span></span>is<span class="hljs-constructor">Empty(<span class="hljs-params">path</span>)</span><span class="hljs-operator"> || </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TextUtils</span>.</span></span>is<span class="hljs-constructor">Empty(<span class="hljs-params">group</span>)</span>) &#123;<br>            throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">HandlerException(Consts.TAG + <span class="hljs-string">&quot;Parameter is invalid!&quot;</span>)</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            PathReplaceService pService = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ARouter</span>.</span></span>get<span class="hljs-constructor">Instance()</span>.navigation(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">PathReplaceService</span>.</span></span><span class="hljs-keyword">class</span>);<br>            <span class="hljs-keyword">if</span> (null != pService) &#123;<br>                path = pService.<span class="hljs-keyword">for</span><span class="hljs-constructor">String(<span class="hljs-params">path</span>)</span>;<br>            &#125;<br>            return <span class="hljs-keyword">new</span> <span class="hljs-constructor">Postcard(<span class="hljs-params">path</span>, <span class="hljs-params">group</span>)</span>;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>.withString(“key3”, “888”).withLong(“key1”, 666L)把参数设置给当前Postcard的bundle中。<br></p><p>再看navigation方法</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs dart">protected <span class="hljs-built_in">Object</span> navigation(<span class="hljs-keyword">final</span> Context context, <span class="hljs-keyword">final</span> Postcard postcard, <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> requestCode, <span class="hljs-keyword">final</span> NavigationCallback callback) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            LogisticsCenter.completion(postcard);<br>        &#125; <span class="hljs-keyword">catch</span> (NoRouteFoundException ex) &#123;<br>            <span class="hljs-keyword">if</span> (debuggable()) &#123;<br>                Toast.makeText(mContext, <span class="hljs-string">&quot;There&#x27;s no route matched!\n&quot;</span> +<br>                        <span class="hljs-string">&quot; Path = [&quot;</span> + postcard.getPath() + <span class="hljs-string">&quot;]\n&quot;</span> +<br>                        <span class="hljs-string">&quot; Group = [&quot;</span> + postcard.getGroup() + <span class="hljs-string">&quot;]&quot;</span>, Toast.LENGTH_LONG).<span class="hljs-keyword">show</span>();<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != callback) &#123;<br>                callback.onLost(postcard);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                DegradeService degradeService = ARouter.getInstance().navigation(DegradeService.<span class="hljs-keyword">class</span>);<br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != degradeService) &#123;<br>                    degradeService.onLost(context, postcard);<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>先看第一部分，重点落在LogisticsCenter.completion(postcard)。内部主要做的是实例化当前group下的具体Route添加到Warehouse.routes，如果没找到就降级处理，两种方式（1.设置NavigationCallback 2.实现DegradeService）</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs dart">public synchronized <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> completion(Postcard postcard) &#123;<br>       RouteMeta routeMeta = Warehouse.routes.<span class="hljs-keyword">get</span>(postcard.getPath());<br>       <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == routeMeta) &#123;<br>           Class&lt;? <span class="hljs-keyword">extends</span> IRouteGroup&gt; groupMeta = Warehouse.groupsIndex.<span class="hljs-keyword">get</span>(postcard.getGroup());<br>           <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == groupMeta) &#123;<br>               <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoRouteFoundException(TAG + <span class="hljs-string">&quot;There is no route match the path [&quot;</span> + postcard.getPath() + <span class="hljs-string">&quot;], in group [&quot;</span> + postcard.getGroup() + <span class="hljs-string">&quot;]&quot;</span>);<br>           &#125; <span class="hljs-keyword">else</span> &#123;<br>               <span class="hljs-keyword">try</span> &#123;<br>                   IRouteGroup iGroupInstance = groupMeta.getConstructor().newInstance();<br>                   iGroupInstance.loadInto(Warehouse.routes);<br>                   Warehouse.groupsIndex.remove(postcard.getGroup());<br>               &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                   <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> HandlerException(TAG + <span class="hljs-string">&quot;Fatal exception when loading group meta. [&quot;</span> + e.getMessage() + <span class="hljs-string">&quot;]&quot;</span>);<br>               &#125;<br>               completion(postcard);<br>           &#125;<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>           postcard.setDestination(routeMeta.getDestination());<br>           postcard.setType(routeMeta.getType());<br>           postcard.setPriority(routeMeta.getPriority());<br>           postcard.setExtra(routeMeta.getExtra());<br><br>           <span class="hljs-built_in">Uri</span> rawUri = postcard.getUri();<br>           <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != rawUri) &#123;<br>               <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">String</span>&gt; resultMap = TextUtils.splitQueryParameters(rawUri);<br>               <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, Integer&gt; paramsType = routeMeta.getParamsType();<br><br>               <span class="hljs-keyword">if</span> (MapUtils.isNotEmpty(paramsType)) &#123;<br>                   <span class="hljs-keyword">for</span> (<span class="hljs-built_in">Map</span>.Entry&lt;<span class="hljs-built_in">String</span>, Integer&gt; params : paramsType.entrySet()) &#123;<br>                       setValue(postcard,<br>                               params.getValue(),<br>                               params.getKey(),<br>                               resultMap.<span class="hljs-keyword">get</span>(params.getKey()));<br>                   &#125;<br>                   postcard.getExtras().putStringArray(ARouter.AUTO_INJECT, paramsType.keySet().toArray(<span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>[]&#123;&#125;));<br>               &#125;<br><br>               postcard.withString(ARouter.RAW_URI, rawUri.toString());<br>           &#125;<br><br>           <span class="hljs-keyword">switch</span> (routeMeta.getType()) &#123;<br>               <span class="hljs-keyword">case</span> PROVIDER:  <br>                   Class&lt;? <span class="hljs-keyword">extends</span> IProvider&gt; providerMeta = (Class&lt;? <span class="hljs-keyword">extends</span> IProvider&gt;) routeMeta.getDestination();<br>                   IProvider instance = Warehouse.providers.<span class="hljs-keyword">get</span>(providerMeta);<br>                   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == instance) &#123;<br>                       IProvider provider;<br>                       <span class="hljs-keyword">try</span> &#123;<br>                           provider = providerMeta.getConstructor().newInstance();<br>                           provider.init(mContext);<br>                           Warehouse.providers.put(providerMeta, provider);<br>                           instance = provider;<br>                       &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> HandlerException(<span class="hljs-string">&quot;Init provider failed! &quot;</span> + e.getMessage());<br>                       &#125;<br>                   &#125;<br>                   postcard.setProvider(instance);<br>                   postcard.greenChannel();<br>                   <span class="hljs-keyword">break</span>;<br>               <span class="hljs-keyword">case</span> FRAGMENT:<br>                   postcard.greenChannel();<br>               <span class="hljs-keyword">default</span>:<br>                   <span class="hljs-keyword">break</span>;<br>           &#125;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>分析一下这段代码</p><ul><li>1.判断Warehouse的routes中对应path的RouteMeta是否为空，看过注解生成类其实我们知道RouteMeta保存了类的具体信息</li><li>2.在集合中找到对应的group分组，然后实例化对应分组下的具体Route添加到集合中</li><li>3.把RouteMeta的各种信息设置给当前postcard对象</li><li>4.uri跳转的处理，uri跳转和普通跳转唯一的区别就是参数的剥离，普通跳转是直接设置的而uri是通过在链接中剥离的，其中参数的数据类型是在Routemeta的paramsType中设置的</li><li>5.根据跳转的类型不同做不同处理。如果是服务，直接实例化当前服务调用init方法并设置给postcard。设置绿色通道；如果是fragment，设置绿色通道。所谓绿色通道就是不被拦截器拦截。</li></ul><p>第二个部分是处理拦截。我们稍后再讲<br><br>先看第三部分</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> Object <span class="hljs-constructor">_navigation(<span class="hljs-params">final</span> Context <span class="hljs-params">context</span>, <span class="hljs-params">final</span> Postcard <span class="hljs-params">postcard</span>, <span class="hljs-params">final</span> <span class="hljs-params">int</span> <span class="hljs-params">requestCode</span>, <span class="hljs-params">final</span> NavigationCallback <span class="hljs-params">callback</span>)</span> &#123;<br>       final Context currentContext = null<span class="hljs-operator"> == </span>context ? mContext : context;<br><br>       switch (postcard.get<span class="hljs-constructor">Type()</span>) &#123;<br>           case ACTIVITY:<br>               final Intent intent = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Intent(<span class="hljs-params">currentContext</span>, <span class="hljs-params">postcard</span>.<span class="hljs-params">getDestination</span>()</span>);<br>               intent.put<span class="hljs-constructor">Extras(<span class="hljs-params">postcard</span>.<span class="hljs-params">getExtras</span>()</span>);<br><br>               <span class="hljs-built_in">int</span> flags = postcard.get<span class="hljs-constructor">Flags()</span>;<br>               <span class="hljs-keyword">if</span> (-<span class="hljs-number">1</span> != flags) &#123;<br>                   intent.set<span class="hljs-constructor">Flags(<span class="hljs-params">flags</span>)</span>;<br>               &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!(currentContext instanceof Activity)) &#123;<br>                   intent.set<span class="hljs-constructor">Flags(Intent.FLAG_ACTIVITY_NEW_TASK)</span>;<br>               &#125;<br><br>               String action = postcard.get<span class="hljs-constructor">Action()</span>;<br>               <span class="hljs-keyword">if</span> (!<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TextUtils</span>.</span></span>is<span class="hljs-constructor">Empty(<span class="hljs-params">action</span>)</span>) &#123;<br>                   intent.set<span class="hljs-constructor">Action(<span class="hljs-params">action</span>)</span>;<br>               &#125;<br><br>               run<span class="hljs-constructor">InMainThread(<span class="hljs-params">new</span> Runnable()</span> &#123;<br>                   @Override<br>                   public void run<span class="hljs-literal">()</span> &#123;<br>                       start<span class="hljs-constructor">Activity(<span class="hljs-params">requestCode</span>, <span class="hljs-params">currentContext</span>, <span class="hljs-params">intent</span>, <span class="hljs-params">postcard</span>, <span class="hljs-params">callback</span>)</span>;<br>                   &#125;<br>               &#125;);<br><br>               break;<br>           case PROVIDER:<br>               return postcard.get<span class="hljs-constructor">Provider()</span>;<br>           case BOARDCAST:<br>           case CONTENT_PROVIDER:<br>           case FRAGMENT:<br>               Class fragmentMeta = postcard.get<span class="hljs-constructor">Destination()</span>;<br>               <span class="hljs-keyword">try</span> &#123;<br>                   Object instance = fragmentMeta.get<span class="hljs-constructor">Constructor()</span>.<span class="hljs-keyword">new</span><span class="hljs-constructor">Instance()</span>;<br>                   <span class="hljs-keyword">if</span> (instance instanceof Fragment) &#123;<br>                       ((Fragment) instance).set<span class="hljs-constructor">Arguments(<span class="hljs-params">postcard</span>.<span class="hljs-params">getExtras</span>()</span>);<br>                   &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (instance instanceof android.support.v4.app.Fragment) &#123;<br>                       ((android.support.v4.app.Fragment) instance).set<span class="hljs-constructor">Arguments(<span class="hljs-params">postcard</span>.<span class="hljs-params">getExtras</span>()</span>);<br>                   &#125;<br><br>                   return instance;<br>               &#125; catch (Exception ex) &#123;<br>                   logger.error(Consts.TAG, <span class="hljs-string">&quot;Fetch fragment instance error, &quot;</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TextUtils</span>.</span></span>format<span class="hljs-constructor">StackTrace(<span class="hljs-params">ex</span>.<span class="hljs-params">getStackTrace</span>()</span>));<br>               &#125;<br>           case METHOD:<br>           case SERVICE:<br>           default:<br>               return null;<br>       &#125;<br><br>       return null;<br>   &#125;<br></code></pre></td></tr></table></figure><p>看到这里是不是很亲切，这不就是我们平时常写的startActivity(intent,class)吗？如果是fragment的话反射调用Fragment构造方法返回fragment对象。provider也是返回<br>Provider对象。至此跳转这一块基本上都搞清楚了。</p><h4>分析一下拦截器是怎么实现的</h4>之前讲了Aroute.init之后会将所有的拦截器实例化。我们看看_ARouter.afterInit()做了什么<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">afterInit</span>(<span class="hljs-params"></span>)</span> &#123;<br>        interceptorService = (InterceptorService) ARouter.getInstance().build(<span class="hljs-string">&quot;/arouter/service/interceptor&quot;</span>).navigation();<br>    &#125;<br></code></pre></td></tr></table></figure><p>使用自己的路由方法初始化interceptorService服务，没毛病。该服务的实现类是InterceptorServiceImpl，从前面的分析可以知道navigation会调用服务的init方法。看看init里面做了什么</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@Override<br>   public void init(final Context context) &#123;<br>       <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LogisticsCenter</span>.</span></span>executor.execute(<span class="hljs-keyword">new</span> <span class="hljs-constructor">Runnable()</span> &#123;<br>           @Override<br>           public void run<span class="hljs-literal">()</span> &#123;<br>               <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">MapUtils</span>.</span></span>is<span class="hljs-constructor">NotEmpty(Warehouse.<span class="hljs-params">interceptorsIndex</span>)</span>) &#123;<br>                   <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, Class&lt;? extends IInterceptor&gt;&gt; entry : <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Warehouse</span>.</span></span>interceptorsIndex.entry<span class="hljs-constructor">Set()</span>) &#123;<br>                       Class&lt;? extends IInterceptor&gt; interceptorClass = entry.get<span class="hljs-constructor">Value()</span>;<br>                       <span class="hljs-keyword">try</span> &#123;<br>                           IInterceptor iInterceptor = interceptorClass.get<span class="hljs-constructor">Constructor()</span>.<span class="hljs-keyword">new</span><span class="hljs-constructor">Instance()</span>;<br>                           iInterceptor.init(context);<br>                           <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Warehouse</span>.</span></span>interceptors.add(iInterceptor);<br>                       &#125; catch (Exception ex) &#123;<br>                           throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">HandlerException(TAG + <span class="hljs-string">&quot;ARouter init interceptor error! name = [&quot;</span> + <span class="hljs-params">interceptorClass</span>.<span class="hljs-params">getName</span>()</span> + <span class="hljs-string">&quot;], reason = [&quot;</span> + ex.get<span class="hljs-constructor">Message()</span> + <span class="hljs-string">&quot;]&quot;</span>);<br>                       &#125;<br>                   &#125;<br><br>                   interceptorHasInit = <span class="hljs-literal">true</span>;<br>               &#125;<br>           &#125;<br>       &#125;);<br>   &#125;<br></code></pre></td></tr></table></figure><p>反射调用所有拦截器的构造函数实例化对象添加到Warehouse.interceptors并调用init方法，这里使用了object.wait和object.notifyAll保证子线程中的所有拦截器实例化完成。拦截的时机在前面已经提到过了，我们来看看具体的代码。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span> (!postcard.is<span class="hljs-constructor">GreenChannel()</span>) &#123;<br>            interceptorService.<span class="hljs-keyword">do</span><span class="hljs-constructor">Interceptions(<span class="hljs-params">postcard</span>, <span class="hljs-params">new</span> InterceptorCallback()</span> &#123;<br>                @Override<br>                public void on<span class="hljs-constructor">Continue(Postcard <span class="hljs-params">postcard</span>)</span> &#123;<br>                    <span class="hljs-constructor">_navigation(<span class="hljs-params">context</span>, <span class="hljs-params">postcard</span>, <span class="hljs-params">requestCode</span>, <span class="hljs-params">callback</span>)</span>;<br>                &#125;<br><br>                @Override<br>                public void on<span class="hljs-constructor">Interrupt(Throwable <span class="hljs-params">exception</span>)</span> &#123;<br>                    <span class="hljs-keyword">if</span> (null != callback) &#123;<br>                        callback.on<span class="hljs-constructor">Interrupt(<span class="hljs-params">postcard</span>)</span>;<br>                    &#125;<br>                &#125;<br>            &#125;);<br></code></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@Override<br>   public void <span class="hljs-keyword">do</span><span class="hljs-constructor">Interceptions(<span class="hljs-params">final</span> Postcard <span class="hljs-params">postcard</span>, <span class="hljs-params">final</span> InterceptorCallback <span class="hljs-params">callback</span>)</span> &#123;<br>       <span class="hljs-keyword">if</span> (null != <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Warehouse</span>.</span></span>interceptors<span class="hljs-operator"> &amp;&amp; </span><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Warehouse</span>.</span></span>interceptors.size<span class="hljs-literal">()</span> &gt; <span class="hljs-number">0</span>) &#123;<br>           <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LogisticsCenter</span>.</span></span>executor.execute(<span class="hljs-keyword">new</span> <span class="hljs-constructor">Runnable()</span> &#123;<br>               @Override<br>               public void run<span class="hljs-literal">()</span> &#123;<br>                   CancelableCountDownLatch interceptorCounter = <span class="hljs-keyword">new</span> <span class="hljs-constructor">CancelableCountDownLatch(Warehouse.<span class="hljs-params">interceptors</span>.<span class="hljs-params">size</span>()</span>);<br>                   <span class="hljs-keyword">try</span> &#123;<br>                       <span class="hljs-constructor">_excute(0, <span class="hljs-params">interceptorCounter</span>, <span class="hljs-params">postcard</span>)</span>;<br>                       interceptorCounter.await(postcard.get<span class="hljs-constructor">Timeout()</span>, TimeUnit.SECONDS);<br>                       <span class="hljs-keyword">if</span> (interceptorCounter.get<span class="hljs-constructor">Count()</span> &gt; <span class="hljs-number">0</span>) &#123;<br>                           callback.on<span class="hljs-constructor">Interrupt(<span class="hljs-params">new</span> HandlerException(<span class="hljs-string">&quot;The interceptor processing timed out.&quot;</span>)</span>);<br>                       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (null != postcard.get<span class="hljs-constructor">Tag()</span>) &#123;   <br>                           callback.on<span class="hljs-constructor">Interrupt(<span class="hljs-params">new</span> HandlerException(<span class="hljs-params">postcard</span>.<span class="hljs-params">getTag</span>()</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>));<br>                       &#125; <span class="hljs-keyword">else</span> &#123;<br>                           callback.on<span class="hljs-constructor">Continue(<span class="hljs-params">postcard</span>)</span>;<br>                       &#125;<br>                   &#125; catch (Exception e) &#123;<br>                       callback.on<span class="hljs-constructor">Interrupt(<span class="hljs-params">e</span>)</span>;<br>                   &#125;<br>               &#125;<br>           &#125;);<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>           callback.on<span class="hljs-constructor">Continue(<span class="hljs-params">postcard</span>)</span>;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> static void <span class="hljs-constructor">_excute(<span class="hljs-params">final</span> <span class="hljs-params">int</span> <span class="hljs-params">index</span>, <span class="hljs-params">final</span> CancelableCountDownLatch <span class="hljs-params">counter</span>, <span class="hljs-params">final</span> Postcard <span class="hljs-params">postcard</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Warehouse</span>.</span></span>interceptors.size<span class="hljs-literal">()</span>) &#123;<br>            IInterceptor iInterceptor = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Warehouse</span>.</span></span>interceptors.get(index);<br>            iInterceptor.process(postcard, <span class="hljs-keyword">new</span> <span class="hljs-constructor">InterceptorCallback()</span> &#123;<br>                @Override<br>                public void on<span class="hljs-constructor">Continue(Postcard <span class="hljs-params">postcard</span>)</span> &#123;<br>                    counter.count<span class="hljs-constructor">Down()</span>;<br>                    <span class="hljs-constructor">_excute(<span class="hljs-params">index</span> + 1, <span class="hljs-params">counter</span>, <span class="hljs-params">postcard</span>)</span>;<br>                &#125;<br><br>                @Override<br>                public void on<span class="hljs-constructor">Interrupt(Throwable <span class="hljs-params">exception</span>)</span> &#123;<br>                    postcard.set<span class="hljs-constructor">Tag(<span class="hljs-params">null</span> <span class="hljs-operator">==</span> <span class="hljs-params">exception</span> ? <span class="hljs-params">new</span> HandlerException(<span class="hljs-string">&quot;No message.&quot;</span>)</span> : <span class="hljs-keyword">exception</span>.get<span class="hljs-constructor">Message()</span>);    <span class="hljs-comment">// save the exception message for backup.</span><br>                    counter.cancel<span class="hljs-literal">()</span>;<br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>使用CountDownLatch.await使得代码阻塞直到所有拦截器执行完成或者超时。拦截器process方法中需要调用callback.onContinue才能调用到counter.countDown()移交到下一个拦截器，这就解释了自定义的拦截器为什么一定要调用counter.countDown()</p><h5>涉及知识点</h5><ul><li>1.线程间通信</li><li>2.CountDownLatch</li><li>3.Object.wait/Object.notify</li></ul><h4>降级处理</h4>两种方式：1.navigation的时候添加NavigationCallback回调 2.写一个类实现DegradeService别忘了添加@Route path可以随意 第一种比较简单我么不讲，讲一下第二种方式<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Route(path = <span class="hljs-meta-string">&quot;/app/degrade1&quot;</span>)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DegradeServiceImpl</span> : <span class="hljs-type">DegradeService &#123;</span></span><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">onLost</span><span class="hljs-params">(context: <span class="hljs-type">Context</span>?, postcard: <span class="hljs-type">Postcard</span>?)</span></span> &#123;<br>        Log.e(<span class="hljs-string">&quot;降级处理&quot;</span>,<span class="hljs-string">&quot;自定义降级处理&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">init</span><span class="hljs-params">(context: <span class="hljs-type">Context</span>?)</span></span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>生成的注解类在ARouter?Providers?app中，也是init的时候就把映射关系添加到集合中。调用的地方是在navigation中，这段代码也间接的说明了NavigationCallback的优先级高于全局降级处理。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span> (null != callback) &#123;<br>                callback.on<span class="hljs-constructor">Lost(<span class="hljs-params">postcard</span>)</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                DegradeService degradeService = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ARouter</span>.</span></span>get<span class="hljs-constructor">Instance()</span>.navigation(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DegradeService</span>.</span></span><span class="hljs-keyword">class</span>);<br>                <span class="hljs-keyword">if</span> (null != degradeService) &#123;<br>                    degradeService.on<span class="hljs-constructor">Lost(<span class="hljs-params">context</span>, <span class="hljs-params">postcard</span>)</span>;<br>                &#125;<br>            &#125;<br></code></pre></td></tr></table></figure><p>关键代码是下面一段代码，诠释了服务的navigation是如何运行的</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">protected &lt;T&gt; T navigation(Class&lt;? extends T&gt; service) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Postcard postcard = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LogisticsCenter</span>.</span></span>build<span class="hljs-constructor">Provider(<span class="hljs-params">service</span>.<span class="hljs-params">getName</span>()</span>);<br>            <span class="hljs-keyword">if</span> (null<span class="hljs-operator"> == </span>postcard) &#123;<br>                postcard = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LogisticsCenter</span>.</span></span>build<span class="hljs-constructor">Provider(<span class="hljs-params">service</span>.<span class="hljs-params">getSimpleName</span>()</span>);<br>            &#125;<br><br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LogisticsCenter</span>.</span></span>completion(postcard);<br>            return (T) postcard.get<span class="hljs-constructor">Provider()</span>;<br>        &#125; catch (NoRouteFoundException ex) &#123;<br>            logger.warning(Consts.TAG, ex.get<span class="hljs-constructor">Message()</span>);<br>            return null;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>buildProvider是根据service的名字从集合中找到对应的RouteMeta并把path和group设置给postcard，接下来也是给postcard设置其他各种参数，和上面分析的大同小异。</p><h4>path动态改变</h4>调用的方式和降级处理一模一样，时机是在build的时候。<h4>参数自动获取（uri方式跳转参数必须加Autowired标记）</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Autowired</span><br><span class="hljs-variable">@JvmField</span><br>var <span class="hljs-attribute">key3</span>: String? = null<br><span class="hljs-variable">@Autowired</span><br><span class="hljs-variable">@JvmField</span><br>var <span class="hljs-attribute">key1</span>: Long = <span class="hljs-number">0</span>L<br><br>ARouter.getInstance().inject(this)<br></code></pre></td></tr></table></figure><p>从文档中可以知道，按照上面的方式就可以自动获取各个参数。关键代码肯定是在inject方法中，调用的还是服务。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-function"><span class="hljs-title">inject</span>(<span class="hljs-params"><span class="hljs-built_in">Object</span> thiz</span>)</span> &#123;<br>        AutowiredService autowiredService = ((AutowiredService) ARouter.getInstance().build(<span class="hljs-string">&quot;/arouter/service/autowired&quot;</span>).navigation());<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != autowiredService) &#123;<br>            autowiredService.autowire(thiz);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>看看AutowiredService的autowire方法</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@Override<br>   public void autowire(Object instance) &#123;<br>       String className = instance.get<span class="hljs-constructor">Class()</span>.get<span class="hljs-constructor">Name()</span>;<br>       <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-keyword">if</span> (!blackList.contains(className)) &#123;<br>               ISyringe autowiredHelper = classCache.get(className);<br>               <span class="hljs-keyword">if</span> (null<span class="hljs-operator"> == </span>autowiredHelper) &#123;<br>                   autowiredHelper = (ISyringe) <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Class</span>.</span></span><span class="hljs-keyword">for</span><span class="hljs-constructor">Name(<span class="hljs-params">instance</span>.<span class="hljs-params">getClass</span>()</span>.get<span class="hljs-constructor">Name()</span> + SUFFIX_AUTOWIRED).get<span class="hljs-constructor">Constructor()</span>.<span class="hljs-keyword">new</span><span class="hljs-constructor">Instance()</span>;<br>               &#125;<br>               autowiredHelper.inject(instance);<br>               classCache.put(className, autowiredHelper);<br>           &#125;<br>       &#125; catch (Exception ex) &#123;<br>           blackList.add(className);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>最关键的方法是XXclass_?ARouter?Autowired.inject，其实这个类还是在注解生成类中</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> TestOneActivity?ARouter?Autowired implements ISyringe &#123;<br>  <span class="hljs-keyword">private</span> SerializationService serializationService;<br><br>  @Override<br>  public void inject(Object target) &#123;<br>    serializationService = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ARouter</span>.</span></span>get<span class="hljs-constructor">Instance()</span>.navigation(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SerializationService</span>.</span></span><span class="hljs-keyword">class</span>);<br>    TestOneActivity substitute = (TestOneActivity)target;<br>    substitute.key3 = substitute.get<span class="hljs-constructor">Intent()</span>.get<span class="hljs-constructor">StringExtra(<span class="hljs-string">&quot;girl&quot;</span>)</span>;<br>    substitute.key1 = substitute.get<span class="hljs-constructor">Intent()</span>.get<span class="hljs-constructor">LongExtra(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-params">substitute</span>.<span class="hljs-params">key1</span>)</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>还是通过getIntent().getExtra方法获取的参数，然后把获取的参数设置给当前类。</p><h4>分析完源码之后扪心自问一下下面问题是否能回答上来</h4><ul><li>1.openLog和openDebug为什么要在init之前？</li><li>2.非Debug环境如何升级路由表——即添加路由？</li><li>3.为什么要自定义线程池？线程池抛出错误的方式有哪几种？</li><li>4.activity的跳转是怎么实现的？</li><li>5.fragment实例是怎么拿到的？为什么不允许拦截？</li><li>6.服务是如何调用的？</li><li>7.path能动态修改吗？在哪个时机修改的？</li><li>8.uri方式是如何跳转的？</li><li>9.路由跳转能否在子线程中？</li><li>10.拦截器怎么实现的？初始化的时机？为什么要在process调用callback.onContinue()。各个拦截器之间的优先级是如何保证的（是在跳转的时候根据priority判断的吗）</li><li>11.全局降级处理怎么实现的，和NavigationCallback谁优先级更高？</li><li>12.如何对path进行预处理，让所有路由失效？</li><li>13.实现多个类继承PathReplaceService、PretreatmentService实际会用哪个。</li></ul><h4>个人的一些思考，大家可以讨论一下</h4><ul><li>1.Fragment未做onActivityResult回调支持，对Fragment的场景还是偏简单了。</li><li>2.插件化是怎么实现路由表的升级的。</li><li>3.自动注册路由表的plugin考虑做增量和并发编译处理，效率有待商榷。</li><li>4.注解实现类的取名Group和path比较容易混淆。</li><li>5.组件跳转结果无法拿到(造成url跳转发起方——比如前端，没有callback，无状态)</li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>源码</tag>
      
      <tag>arouter</tag>
      
      <tag>路由</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小菜鸟想去大厂的神秘宝典</title>
    <link href="/2021/07/07/interview/"/>
    <url>/2021/07/07/interview/</url>
    
    <content type="html"><![CDATA[<p>本文针对于学历出生不是很好又想进入大厂的猿猿。<br></p><p>为什么是大厂？</p><ul><li>大环境的冲击——客三消的说法虽然有点夸张，但是现在对于客户端来说大环境确实不是很好。中小厂出于成本考虑会进一步缩减客户端人员的成本，大多数投入了小程序、RN、Flutter的怀抱。说句不好听的大厂才能养得起或者说愿意养客户端开发。</li><li>大厂职级薪资健全，只要你面上了那个职级，即使不能拿到职级的最高薪也不会差到哪里去。而中小厂会根据你上家公司的薪资疯狂压你薪水，其次大厂相对于中小厂肯定好一些。当然也有薪资福利好的中小厂（麻烦告诉我咱家公司叫什么）。</li><li>大厂职位多，内部转岗可选择性多。客户端毕竟不是长久之计。</li></ul><h3 id="时机"><a href="#时机" class="headerlink" title="时机"></a>时机</h3><p>个人觉得年前11月份出去面最好。一个是竞争比较小，大厂的精英都在等着拿完年终奖或者年底双薪跑路。这时候你出去面试，面对的是同一水平的人，等到年后三四月份那就是神仙打架，鹿死谁手可就不知道了；另一个是11月份hr们都在补足明年的人员，相对来说hc还是比较多的，等到1月份大多在忙年终年会的事，hc会少很多，流程也会走得很慢。提醒一句：随时做好失去年终奖的准备。<br></p><p>真的等到11月份才出去面？我说的11月份当然不是让你真的等到11月份才出去，11月份出去的时候是我们必须拿下的。前后也就两个月时间，如果拿不下只能等来年再战了，所以我们不容有失。个人建议8、9月份出去试试水，试水也不能瞎逼试，找同等的或者高一等的大厂去试，千万不要去中小厂试，套路完全是不一样的。</p><h3 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h3><p>简历不要乱写，不要把什么项目都写上。一个是根据公司招聘的JD，另一个是根据目前热门的技术。写项目业界有比较成熟的STAR法则，简单的说就是在什么项目你接到了什么任务做了什么产生了什么结果（有准确的数据更好）；JD针对性的东西可以多些。<br></p><p>简历的亮点？第一个是有自己独到见解思考的项目，第二个对于客户端同学来说掌握前端、客户端和h5交互、跨端技术绝对是一个亮点，如果做过这方面项目也建议写上。<br></p><p>能走内推就走内推，找高职级的人内推更好。</p><h3 id="硬实力"><a href="#硬实力" class="headerlink" title="硬实力"></a>硬实力</h3><p>简历上写的项目一定要滚瓜烂熟，项目涉及什么知识点？这些知识点可以发散出什么知识点？这个项目给团队带来了什么？有没有做过横向的对比，为什么选择这个方案？方案还有没有优化空间？<br></p><p>java基础和Android基础一定要掌握，该背八股文的就去背。java方面建议去看《Java编程的逻辑》,Android方面可以先看看《Android技术探索》。注意看的过程中多一些自己的思考。<br></p><p>算法练习，现在越来越多的大厂会考察算法。至于为什么考察算法，一个是考验你这个人认不认真，有没有去好好准备；还有一个就是考验你聪不聪明。客户端算法题考察leetcode简单中等题，可以去leetcode做对应练习，有思路也一定要手写一下。一定要练得滚瓜烂熟，高压状态下很容易写错。如果觉得leetcode题目太多，有一个捷径——把《剑指offer》的题目都认真做一遍。<br></p><p>设计模式准备几个，特别是和实际项目结合的，不要说来说去就一个单例。<br></p><p>有针对性的放弃一些公司。如果觉得项目的知识点准备不全，就去面试阿里，阿里对于业务相关的东西问得特别细，会让你整体思考上一个台阶。要试自己的算法水平就去快手和头条其中一家面试，当然这也就意味着这家公司短时间可能与你无缘了，自己想好就行。</p><h3 id="方法论"><a href="#方法论" class="headerlink" title="方法论"></a>方法论</h3><ul><li>千万不要一股脑的狂投简历，杭州大厂就那么几家，且行且珍惜。</li><li>先去自己不想去和觉得自己面不上的公司面。</li><li>实在进不了大厂，可以先去不错的中厂，走迂回道路。</li><li>被hr问手头上有没有offer的时候，简单的回答可以说在走流程，但是贵公司的职位对我来说更契合。说没有offer会被压薪资，后面也没有争取的资本。</li></ul><p>以上是自己一点小小的心得，希望可以给各位一点小小的帮助，不对的地方还望轻喷。</p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>互联网</tag>
      
      <tag>大厂</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>『全网独一份』Flutter混合工程一键打aar上传Artifactory</title>
    <link href="/2021/07/07/flutter%E4%BA%A7%E7%89%A9%E5%BD%92%E6%A1%A3/"/>
    <url>/2021/07/07/flutter%E4%BA%A7%E7%89%A9%E5%BD%92%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="官方方案"><a href="#官方方案" class="headerlink" title="官方方案"></a>官方方案</h2><p>首先我们先看一下官方提供的混合工程接入方案，链接地址<a href="https://flutter.dev/docs/development/add-to-app/android/project-setup">https://flutter.dev/docs/development/add-to-app/android/project-setup</a> 总共提供两种接入方式：</p><ul><li>以module方式接入</li><li>以本地maven方式接入</li></ul><p>两种接入方式都比较简单，前提都是<strong>先创建Flutter Module</strong>（flutter相关代码写在这边）。</p><p><img src="/img/flutter_a_1.png"></p><h3 id="以module方式接入"><a href="#以module方式接入" class="headerlink" title="以module方式接入"></a>以module方式接入</h3><p>以module方式接入首先在Android工程的settings.gradle加入:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle">setBinding(<span class="hljs-keyword">new</span> Binding([gradle: <span class="hljs-keyword">this</span>]))                                <br>evaluate(<span class="hljs-keyword">new</span> <span class="hljs-keyword">File</span>(                                                     <br>  settingsDir.parentFile,                                              <br>  <span class="hljs-string">&#x27;my_flutter/.android/include_flutter.groovy&#x27;</span>    <span class="hljs-comment">//注意这边flutter module路径的正确性                     </span><br>))   <br></code></pre></td></tr></table></figure><p>这时候工程中就会很神奇的多出一个flutter module，在工程中引入这个flutter module就可以了。例如在app的build.gradle中添加:</p><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">implementation</span> <span class="hljs-function"><span class="hljs-title">project</span>(<span class="hljs-string">&#x27;:flutter&#x27;</span>)</span><br></code></pre></td></tr></table></figure><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>setBinding和evaluate都是groovy语法，这里所做的事就是运行 include_flutter.groovy 脚本；而setBinding的作用是把gradle环境传入include_flutter.groovy内（因为里面需要使用到gradle环境）。运行groovy文件，文件运行在一个Script对象中，Script有一个属性binding，内部存储了当前环境的变量（包括当前脚本声明的变量与启动脚本传入的参数），evaluate执行时会把当前脚本的binding传入下一个脚本。下面是include_flutter.groovy中的关键代码:</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle">gradle.<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;:flutter&quot;</span><br>gradle.<span class="hljs-keyword">project</span>(<span class="hljs-string">&quot;:flutter&quot;</span>).projectDir = <span class="hljs-keyword">new</span> <span class="hljs-keyword">File</span>(flutterProjectRoot, <span class="hljs-string">&quot;.android/Flutter&quot;</span>)<br><span class="hljs-keyword">def</span> flutterSdkPath = properties.getProperty(<span class="hljs-string">&quot;flutter.sdk&quot;</span>)<br>gradle.apply <span class="hljs-keyword">from</span>: <span class="hljs-string">&quot;$flutterSdkPath/packages/flutter_tools/gradle/module_plugin_loader.gradle&quot;</span><br></code></pre></td></tr></table></figure><p>添加flutter module到Android工程中，导入module_plugin_loader.gradle脚本片段。简单看一下module_plugin_loader.gradle中的关键代码</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">def pluginsFile = <span class="hljs-keyword">new</span> <span class="hljs-constructor">File(<span class="hljs-params">moduleProjectRoot</span>, &#x27;.<span class="hljs-params">flutter</span>-<span class="hljs-params">plugins</span>-<span class="hljs-params">dependencies</span>&#x27;)</span><br><span class="hljs-keyword">if</span> (pluginsFile.exists<span class="hljs-literal">()</span>) &#123;<br>    def <span class="hljs-keyword">object</span> = <span class="hljs-keyword">new</span> <span class="hljs-constructor">JsonSlurper()</span>.parse<span class="hljs-constructor">Text(<span class="hljs-params">pluginsFile</span>.<span class="hljs-params">text</span>)</span><br>    <span class="hljs-keyword">object</span>.plugins.android.each &#123; androidPlugin -&gt;<br>        def pluginDirectory = <span class="hljs-keyword">new</span> <span class="hljs-constructor">File(<span class="hljs-params">androidPlugin</span>.<span class="hljs-params">path</span>, &#x27;<span class="hljs-params">android</span>&#x27;)</span><br>        <span class="hljs-keyword">include</span> <span class="hljs-string">&quot;:$&#123;androidPlugin.name&#125;&quot;</span><br>        project(<span class="hljs-string">&quot;:$&#123;androidPlugin.name&#125;&quot;</span>).projectDir = pluginDirectory<br>    &#125;<br>&#125;  <br></code></pre></td></tr></table></figure><p>简单的说就是添加所有插件module到Android工程中，那么这些插件module从哪里来。插个题外话讲一下flutter的<strong>插件管理</strong>，官方的插件托管平台是<a href="https://pub.dev,/">https://pub.dev，</a><br>flutter是用配置文件pubspec.yaml来管理三方插件的（类似于前端的npm）,配置某个三方依赖类似如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">dependencies</span>:<br>  <span class="hljs-attribute">path_provider</span>: ^<span class="hljs-number">1</span>.<span class="hljs-number">6</span>.<span class="hljs-number">18</span><br></code></pre></td></tr></table></figure><p>然后执行Pub.get，会做两件事情：</p><ul><li>把插件的源代码下载到本地，具体位置在<strong>flutterRoot/.pub-cache</strong>目录下</li><li>更新.flutter-plugins和.flutter-plugins-dependencies文件</li></ul><p>.flutter-plugins和.flutter-plugins-dependencies以json的形式存储了插件名字和对应的本地工程地址，上面添加插件module到Android工程有用到，看一眼里面存储的东西:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">path_provider_macos=<span class="hljs-regexp">/Users/</span>liuxiaoshuai<span class="hljs-regexp">/flutter/</span>.pub-cache<span class="hljs-regexp">/hosted/</span>pub.flutter-io.cn<span class="hljs-regexp">/path_provider_macos-0.0.4+3/</span><br></code></pre></td></tr></table></figure><p>pub管理不像gradle依赖管理那么智能，一定要注意<strong>冲突的处理！</strong></p><p>总结一下settings.gradle添加配置所做的事:</p><ol><li>include FlutterModule中的.android/Flutter工程</li><li>include FlutterModule中.flutter-plugins文件中包含的Flutter工程路径下的android module</li><li>配置所有工程的build.gradle配置执行阶段都依赖于:flutter工程，也即它最先执行配置阶段</li></ol><p>所有的module都加进来了，总感觉差点什么：我们在FlutterModule中写的dart代码以及引擎是怎么加入到Android工程中的呢？答案藏在flutter module的build.gradle中，里面有一句特别关键的代码</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">def</span> flutterRoot = localProperties.getProperty(<span class="hljs-string">&#x27;flutter.sdk&#x27;</span>)<br>apply <span class="hljs-keyword">from</span>: <span class="hljs-string">&quot;$flutterRoot/packages/flutter_tools/gradle/flutter.gradle&quot;</span><br></code></pre></td></tr></table></figure><p>剩余的所有工作在flutter.gradle中做，flutter.gradle中的代码太长，我这里就不贴了，但是里面的代码<strong>特别重要</strong>，记得去看。这里先总结一下内部所做的事:</p><ol><li>选择符合对应架构的Flutter引擎</li><li>插入Flutter Plugin的编译依赖（默认aar依赖）</li><li>Hook mergeAssets/processResources Task，预先执行FlutterTask，调用flutter命令编译Dart层代码构建出flutter_assets产物，并拷贝到assets目录下（dart代码产物）</li></ol><p>到这里插件和dart代码都添加到了Android工程中</p><h3 id="以本地maven方式接入"><a href="#以本地maven方式接入" class="headerlink" title="以本地maven方式接入"></a>以本地maven方式接入</h3><p>首先通过flutter shell脚本打出对应的产物，常用命令如下:</p><ul><li>flutter build aar</li><li>flutter build aar –no-debug –no-profile //只打release产物</li><li>flutter build aar–build-number=2.0 //版本控制</li></ul><p>执行命令之后在下图所示位置查看产物:</p><p><img src="/img/flutter_a_2.png"></p><p>接下来使用产物，settings.gradle中就不需要做额外的配置了：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">repositories</span> &#123;<br>  <span class="hljs-section">maven</span> &#123;<br>    <span class="hljs-attribute">url</span> <span class="hljs-string">&#x27;../FlutterModule/build/host/outputs/repo&#x27;</span> //注意路径的正确性<br>  &#125;<br>&#125;<br>dependencies &#123;<br>  <span class="hljs-attribute">implementation</span> <span class="hljs-string">&#x27;com.example.flutter_module:flutter_release:1.0&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="官方方案缺陷"><a href="#官方方案缺陷" class="headerlink" title="官方方案缺陷"></a>官方方案缺陷</h2><p>以module方式接入：</p><ol><li>需要团队成员都安装有flutter开发环境，对于不开发flutter的同学侵入性太大；同时对于新来的同学需要安装的环境变多，加大了负担。</li><li>需要修改ci流程，原先ci流程中肯定是不包含flutter流程的。</li></ol><p>以本地maven的方式接入：</p><ol><li>版本不好管理</li><li>需要把本地产物拷贝给其他不开发flutter的同学，否则本质上还是需要安装flutter开发环境。</li></ol><p>那么考虑能不能利用flutter build aar打出的产物，将产物提交到公司的私仓，这样所有同学就都能正常下载使用了。理论上这个方案是可行的，遍历build/host/outputs/repo下所有的文件夹，然后将产物依次提交。方案没有实践过，大家可以试试。</p><h2 id="全新的方案"><a href="#全新的方案" class="headerlink" title="全新的方案"></a>全新的方案</h2><p>我的方案是自己插手产物的构建和上传，整套操作是一个shell脚本，同时会依赖于外部的配置。</p><p><img src="/img/flutter_a_3.png"></p><h4 id="第一个配置文件gradle-properties"><a href="#第一个配置文件gradle-properties" class="headerlink" title="第一个配置文件gradle.properties"></a>第一个配置文件gradle.properties</h4><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># 远程maven url和账号</span><br><span class="hljs-attr">MAVEN_URL</span>=http://<span class="hljs-number">172.16</span>.<span class="hljs-number">9.30</span>:<span class="hljs-number">8081</span>/artifactory/<br><span class="hljs-attr">MAVEN_ACCOUNT_NAME</span>=***<br><span class="hljs-attr">MAVEN_ACCOUNT_PWD</span>=***<br><br><span class="hljs-attr">GROUP</span>=com.lxs.flutter<br><span class="hljs-attr">VERSION_NAME</span>=<span class="hljs-number">0.0</span>.<span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>用于设置私仓的地址、用户名、密码。产物的group、版本</p><h4 id="第二个配置文件build-gradle"><a href="#第二个配置文件build-gradle" class="headerlink" title="第二个配置文件build.gradle"></a>第二个配置文件build.gradle</h4><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">buildscript</span> &#123;<br>    <span class="hljs-keyword">repositories</span> &#123;<br>        google()<br>        jcenter()<br>    &#125;<br><br>    <span class="hljs-keyword">dependencies</span> &#123;<br>        <span class="hljs-keyword">classpath</span> <span class="hljs-string">&#x27;com.android.tools.build:gradle:3.5.0&#x27;</span><br>        <span class="hljs-keyword">classpath</span> <span class="hljs-string">&quot;org.jfrog.buildinfo:build-info-extractor-gradle:4.8.1&quot;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">allprojects</span> &#123;<br>    <span class="hljs-keyword">repositories</span> &#123;<br>        google()<br>        jcenter()<br>    &#125;<br>    apply plugin: <span class="hljs-string">&#x27;com.jfrog.artifactory&#x27;</span><br>    apply plugin: <span class="hljs-string">&#x27;maven-publish&#x27;</span><br>&#125;<br><br><span class="hljs-keyword">task</span> clean(type: <span class="hljs-keyword">Delete</span>) &#123;<br>    <span class="hljs-keyword">delete</span> rootProject.buildDir<br>&#125;<br><br><span class="hljs-keyword">subprojects</span> &#123;<br>    <span class="hljs-keyword">project</span>.afterEvaluate &#123;<br>        <span class="hljs-keyword">project</span>.plugins.withId(<span class="hljs-string">&#x27;com.android.library&#x27;</span>) &#123;<br>            <span class="hljs-keyword">project</span>.<span class="hljs-keyword">group</span> = <span class="hljs-keyword">GROUP</span><br>            <span class="hljs-keyword">project</span>.version = VERSION_NAME<br>            <span class="hljs-keyword">def</span> mavenScriptPath = <span class="hljs-keyword">project</span>.rootProject.<span class="hljs-keyword">file</span>(<span class="hljs-string">&#x27;./config/flutter_jfrog.gradle&#x27;</span>)<br>            <span class="hljs-keyword">project</span>.apply <span class="hljs-keyword">from</span>: mavenScriptPath<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意.android目录在每次pub get之后会重新构建，所以不能直接在.android工程中修改，这里直接用外部配置文件覆盖的方式。因为产物的上传需要依赖jfrog插件，所以build.gradle中做了jfrog的相应配置。还有一点就是group和version的矫正，因为flutter module中添加插件二进制会使用到group和version。具体代码在flutter.gradle中</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configurePluginAar</span><span class="hljs-params">(<span class="hljs-keyword">String</span> pluginName, <span class="hljs-keyword">String</span> pluginPath, Project project)</span> </span>&#123;<br>        <span class="hljs-built_in">File</span> pluginBuildFile = project.<span class="hljs-built_in">file</span>(Paths.<span class="hljs-built_in">get</span>(pluginPath, <span class="hljs-string">&quot;android&quot;</span>, <span class="hljs-string">&quot;build.gradle&quot;</span>));<br>        <span class="hljs-keyword">if</span> (!pluginBuildFile.<span class="hljs-built_in">exists</span>()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">GradleException</span>(<span class="hljs-string">&quot;Plugin $pluginName doesn&#x27;t have the required file $pluginBuildFile.&quot;</span>)<br>        &#125;<br>        <br>        Matcher groupParts = GROUP_PATTERN.<span class="hljs-built_in">matcher</span>(pluginBuildFile.text)<br>        <span class="hljs-keyword">String</span> groupId = groupParts[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]<br>        <span class="hljs-built_in">File</span> pluginSettings = project.<span class="hljs-built_in">file</span>(Paths.<span class="hljs-built_in">get</span>(pluginPath, <span class="hljs-string">&quot;android&quot;</span>, <span class="hljs-string">&quot;settings.gradle&quot;</span>));<br>        <span class="hljs-keyword">if</span> (!pluginSettings.<span class="hljs-built_in">exists</span>()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">GradleException</span>(<span class="hljs-string">&quot;Plugin $pluginName doesn&#x27;t have the required file $pluginSettings.&quot;</span>)<br>        &#125;<br>        Matcher projectNameParts = PROJECT_NAME_PATTERN.<span class="hljs-built_in">matcher</span>(pluginSettings.text)<br>        <span class="hljs-keyword">String</span> artifactId = <span class="hljs-string">&quot;$&#123;projectNameParts[0][1]&#125;_release&quot;</span><br>        <br>        project.dependencies.<span class="hljs-built_in">add</span>(<span class="hljs-string">&quot;api&quot;</span>, <span class="hljs-string">&quot;$groupId:$artifactId:+&quot;</span>)<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="第三个配置文件flutter-jfrog-gradle"><a href="#第三个配置文件flutter-jfrog-gradle" class="headerlink" title="第三个配置文件flutter_jfrog.gradle"></a>第三个配置文件flutter_jfrog.gradle</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">import com.sun.tools.classfile.Dependency<br><br>task android<span class="hljs-constructor">SourcesJar(<span class="hljs-params">type</span>: Jar)</span> &#123;<br>    classifier = &#x27;sources&#x27;<br>    from android.sourceSets.main.java.srcDirs<br>&#125;<br><br>assemble.dependsOn androidSourcesJar<br><br>publishing &#123;<br>    publications &#123;<br>        aar(MavenPublication) &#123;<br>            groupId = GROUP<br>            version = VERSION_NAME<br>            artifactId = project.name<br>            artifact(<span class="hljs-string">&quot;$buildDir/outputs/aar/$&#123;project.getName()&#125;-release.aar&quot;</span>)<br>            artifact androidSourcesJar<br><br>            pom.withXml &#123;<br>                def dependenciesNode = <span class="hljs-keyword">as</span><span class="hljs-constructor">Node()</span>.append<span class="hljs-constructor">Node(&#x27;<span class="hljs-params">dependencies</span>&#x27;)</span><br><br>                def compileTimeDependencies =<br>                        configurations.implementation.allDependencies.<span class="hljs-keyword">with</span><span class="hljs-constructor">Type(ModuleDependency)</span> +<br>                                configurations.releaseImplementation.allDependencies.<span class="hljs-keyword">with</span><span class="hljs-constructor">Type(ModuleDependency)</span><br><br>                append<span class="hljs-constructor">Dependencies(<span class="hljs-params">compileTimeDependencies</span>, <span class="hljs-params">dependenciesNode</span>)</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br>artifactory &#123;<br>    contextUrl = MAVEN_URL<br>    publish &#123;<br>        repository &#123;<br>            repoKey = &#x27;gradle-dev-local&#x27;<br>            username = MAVEN_ACCOUNT_NAME<br>            password = MAVEN_ACCOUNT_PWD<br>        &#125;<br>        defaults &#123;<br>            <span class="hljs-comment">// Tell the Artifactory Plugin which artifacts should be published to Artifactory.</span><br>            publications(&#x27;aar&#x27;)<br>            publishArtifacts = <span class="hljs-literal">true</span><br>            <span class="hljs-comment">// Properties to be attached to the published artifacts.</span><br>            properties = <span class="hljs-literal">[&#x27;<span class="hljs-identifier">qa</span>.<span class="hljs-identifier">level</span>&#x27;: &#x27;<span class="hljs-identifier">basic</span>&#x27;, &#x27;<span class="hljs-identifier">dev</span>.<span class="hljs-identifier">team</span>&#x27;: &#x27;<span class="hljs-identifier">core</span>&#x27;]</span><br>            <span class="hljs-comment">// Publish generated POM files to Artifactory (true by default)</span><br>            publishPom = <span class="hljs-literal">true</span><br>        &#125;<br>    &#125;<br>&#125;<br><br>ext &#123;<br>    appendDependencies = &#123; Set&lt;Dependency&gt; compileTimeDependencies, dependenciesNode -&gt;<br><br>        compileTimeDependencies.each &#123;<br>            <span class="hljs-comment">// 过滤library引用</span><br>            <span class="hljs-keyword">if</span> (it.version != <span class="hljs-string">&quot;unspecified&quot;</span>) &#123;<br>                def dependencyNode = dependenciesNode.append<span class="hljs-constructor">Node(&#x27;<span class="hljs-params">dependency</span>&#x27;)</span><br>                dependencyNode.append<span class="hljs-constructor">Node(&#x27;<span class="hljs-params">groupId</span>&#x27;, <span class="hljs-params">it</span>.<span class="hljs-params">group</span>)</span><br>                dependencyNode.append<span class="hljs-constructor">Node(&#x27;<span class="hljs-params">artifactId</span>&#x27;, <span class="hljs-params">it</span>.<span class="hljs-params">name</span>)</span><br>                dependencyNode.append<span class="hljs-constructor">Node(&#x27;<span class="hljs-params">version</span>&#x27;, <span class="hljs-params">it</span>.<span class="hljs-params">version</span>)</span><br><br>                <span class="hljs-keyword">if</span> (!it.excludeRules.is<span class="hljs-constructor">Empty()</span>) &#123;<br>                    def exclusionsNode = dependencyNode.append<span class="hljs-constructor">Node(&#x27;<span class="hljs-params">exclusions</span>&#x27;)</span><br>                    it.excludeRules.each &#123; rule -&gt;<br>                        def exclusionNode = exclusionsNode.append<span class="hljs-constructor">Node(&#x27;<span class="hljs-params">exclusion</span>&#x27;)</span><br>                        exclusionNode.append<span class="hljs-constructor">Node(&#x27;<span class="hljs-params">groupId</span>&#x27;, <span class="hljs-params">rule</span>.<span class="hljs-params">group</span>)</span><br>                        exclusionNode.append<span class="hljs-constructor">Node(&#x27;<span class="hljs-params">artifactId</span>&#x27;, <span class="hljs-params">rule</span>.<span class="hljs-params">module</span> ?: &#x27;<span class="hljs-operator">*</span>&#x27;)</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主要是产物的收集和上传，implementation依赖中不包含releaseImplementation，需要注意<strong>聚合implementation和releaseImplementation</strong>。（因为flutter module中引擎的依赖方式是releaseImplementation）</p><p>接下来分析脚本，第一步是版本号的更新。提供了两种方式：1.脚本参数 2.自动升级 添加了脚本参数的情况下取消自动升级</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">num</span>=<span class="hljs-variable">$#</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-variable">$num</span> -eq 0 ];then<br>  updateVersion<br><span class="hljs-keyword">else</span><br>  <span class="hljs-attribute">v</span>=$(grep VERSION_NAME configs/gradle.properties|cut -d<span class="hljs-string">&#x27;=&#x27;</span> -f2)<br>  sed -i <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-string">&#x27;s/VERSION_NAME=&#x27;</span><span class="hljs-variable">$v</span><span class="hljs-string">&#x27;/VERSION_NAME=&#x27;</span><span class="hljs-variable">$1</span><span class="hljs-string">&#x27;/g&#x27;</span> configs/gradle.properties<br>  echo <span class="hljs-string">&#x27;更新版本号成功...&#x27;</span><br>fi<br></code></pre></td></tr></table></figure><p>版本号自动升级，自动升级基于上次版本做加一操作</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> update<span class="hljs-constructor">Version()</span> &#123;<br>  v=<span class="hljs-constructor">$(<span class="hljs-params">grep</span> VERSION_NAME <span class="hljs-params">configs</span><span class="hljs-operator">/</span><span class="hljs-params">gradle</span>.<span class="hljs-params">properties</span>|<span class="hljs-params">cut</span> -<span class="hljs-params">d</span>&#x27;=&#x27; -<span class="hljs-params">f2</span>)</span><br>  echo 旧版本号$v<br>  v1=<span class="hljs-constructor">$(<span class="hljs-params">echo</span> | <span class="hljs-params">awk</span> &#x27;&#123;<span class="hljs-params">split</span>(<span class="hljs-string">&quot;&#x27;$v&#x27;&quot;</span>,<span class="hljs-params">array</span>,<span class="hljs-string">&quot;.&quot;</span>)</span>; print <span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-number">1</span>]</span>&#125;&#x27;)<br>  v2=<span class="hljs-constructor">$(<span class="hljs-params">echo</span> | <span class="hljs-params">awk</span> &#x27;&#123;<span class="hljs-params">split</span>(<span class="hljs-string">&quot;&#x27;$v&#x27;&quot;</span>,<span class="hljs-params">array</span>,<span class="hljs-string">&quot;.&quot;</span>)</span>; print <span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-number">2</span>]</span>&#125;&#x27;)<br>  v3=<span class="hljs-constructor">$(<span class="hljs-params">echo</span> | <span class="hljs-params">awk</span> &#x27;&#123;<span class="hljs-params">split</span>(<span class="hljs-string">&quot;&#x27;$v&#x27;&quot;</span>,<span class="hljs-params">array</span>,<span class="hljs-string">&quot;.&quot;</span>)</span>; print <span class="hljs-built_in">array</span><span class="hljs-literal">[<span class="hljs-number">3</span>]</span>&#125;&#x27;)<br>  y=<span class="hljs-constructor">$(<span class="hljs-params">expr</span> $<span class="hljs-params">v3</span> + 1)</span><br><br>  <span class="hljs-keyword">if</span> <span class="hljs-literal">[ <span class="hljs-identifier">$y</span> -<span class="hljs-identifier">ge</span> <span class="hljs-number">10</span> ]</span>;<span class="hljs-keyword">then</span><br>    y=<span class="hljs-constructor">$(<span class="hljs-params">expr</span> $<span class="hljs-params">y</span> % 10)</span><br>    v2=<span class="hljs-constructor">$(<span class="hljs-params">expr</span> $<span class="hljs-params">v2</span> + 1)</span><br>  fi<br><br>  <span class="hljs-keyword">if</span> <span class="hljs-literal">[ <span class="hljs-identifier">$v2</span> -<span class="hljs-identifier">ge</span> <span class="hljs-number">10</span> ]</span>;<span class="hljs-keyword">then</span><br>    v2=<span class="hljs-constructor">$(<span class="hljs-params">expr</span> $<span class="hljs-params">v2</span> % 10)</span><br>    v1=<span class="hljs-constructor">$(<span class="hljs-params">expr</span> $<span class="hljs-params">v1</span> + 1)</span><br>  fi<br><br>  vv=$v1<span class="hljs-string">&quot;.&quot;</span>$v2<span class="hljs-string">&quot;.&quot;</span>$y<br>  echo 新版本号$vv<br>  # 更新配置文件<br>  sed -i &#x27;<span class="hljs-character">&#x27; &#x27;</span>s/VERSION_NAME=&#x27;$v&#x27;/VERSION_NAME=&#x27;$vv&#x27;/g&#x27; configs/gradle.properties<br>  <span class="hljs-keyword">if</span> <span class="hljs-literal">[ <span class="hljs-identifier">$</span>? -<span class="hljs-identifier">eq</span> <span class="hljs-number">0</span> ]</span>; <span class="hljs-keyword">then</span><br>      echo &#x27;&#x27;<br>  <span class="hljs-keyword">else</span><br>      echo &#x27;更新版本号失败...&#x27;<br>      exit<br>  fi<br>&#125;<br></code></pre></td></tr></table></figure><p>第二步把配置copy到.android工程中</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">if</span> [  -d <span class="hljs-string">&#x27;.android/config/&#x27;</span> ]; then<br>   echo <span class="hljs-string">&#x27;.android/config 文件夹已存在&#x27;</span><br><span class="hljs-keyword">else</span> :<br>   mkdir .android/config<br>fi<br><br>cp configs<span class="hljs-regexp">/gradle.properties .android/g</span>radle.properties<br>cp configs<span class="hljs-regexp">/flutter_jfrog.gradle .android/</span>config/flutter_jfrog.gradle<br>cp configs<span class="hljs-regexp">/build.gradle .android/</span>build.gradle<br></code></pre></td></tr></table></figure><p>第三步各个plugin module单独打aar，构建收集产物上传</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> <span class="hljs-variable">$</span>(<span class="hljs-built_in">cat</span> .flutter<span class="hljs-literal">-plugins</span> | grep <span class="hljs-literal">-v</span> <span class="hljs-string">&#x27;^ *#&#x27;</span>)<br><span class="hljs-keyword">do</span><br>    plugin_name=<span class="hljs-variable">$</span>&#123;line%%=*&#125;<br>    plugin_path=<span class="hljs-variable">$</span>&#123;line<span class="hljs-comment">##*=&#125;</span><br>    res=<span class="hljs-variable">$</span>(doesSupportAndroidPlatform <span class="hljs-variable">$</span>&#123;plugin_path&#125;)<br>    <span class="hljs-keyword">if</span> [ <span class="hljs-variable">$res</span> -<span class="hljs-type">eq</span> <span class="hljs-number">0</span> ];then<br>      ./gradlew <span class="hljs-string">&quot;<span class="hljs-variable">$</span>&#123;plugin_name&#125;&quot;</span>:clean<br>      ./gradlew <span class="hljs-string">&quot;<span class="hljs-variable">$</span>&#123;plugin_name&#125;&quot;</span>:assembleRelease<br>      ./gradlew <span class="hljs-string">&quot;<span class="hljs-variable">$</span>&#123;plugin_name&#125;&quot;</span>:artifactoryPublish<br>    fi<br>done<br></code></pre></td></tr></table></figure><p>第四步flutter module打aar，构建收集产物上传</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">./gradlew</span> clean assembleRelease<br><span class="hljs-string">./gradlew</span> flutter<span class="hljs-function">:artifactoryPublish</span><br></code></pre></td></tr></table></figure><p>产物上传到私仓之后就能正常使用了，使用方式和本地maven类似；还有一项工作就是源码和二进制切换的配置。开发阶段还是需要以module方式依赖的，因为调试和hot reload更加方便。工程远程分支保持二进制依赖，通过本地配置来打开源码依赖，这种方式侵入最小，这里就想到在local.properties中添加配置</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">flutterAar</span>=<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>settings.gradle中修改为</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">def</span> localProperties = readPropertiesIfExist(<span class="hljs-keyword">new</span> <span class="hljs-keyword">File</span>(<span class="hljs-string">&quot;local.properties&quot;</span>))<br><br><span class="hljs-keyword">if</span> (!localProperties.getProperty(<span class="hljs-string">&quot;flutterAar&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>).toBoolean()) &#123;<br>    <span class="hljs-keyword">def</span> flutterFile = <span class="hljs-keyword">new</span> <span class="hljs-keyword">File</span>(settingsDir.parentFile,<br>            <span class="hljs-string">&#x27;flutter_module/.android/include_flutter.groovy&#x27;</span>)<br>    <span class="hljs-keyword">if</span> (flutterFile.exists()) &#123;<br>        setBinding(<span class="hljs-keyword">new</span> Binding([gradle: <span class="hljs-keyword">this</span>]))<br>        evaluate(flutterFile)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> GradleException(<span class="hljs-string">&quot;flutter module does not exit,please check the path&quot;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Properties readPropertiesIfExist(<span class="hljs-keyword">File</span> propertiesFile) &#123;<br>    Properties result = <span class="hljs-keyword">new</span> Properties()<br>    <span class="hljs-keyword">if</span> (propertiesFile.exists()) &#123;<br>        propertiesFile.<span class="hljs-keyword">withReader</span>(<span class="hljs-string">&#x27;UTF-8&#x27;</span>) &#123; reader -&gt; result.load(reader) &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure><p>添加module的地方修改为</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">def</span> localProperties = readPropertiesIfExist(<span class="hljs-keyword">new</span> <span class="hljs-keyword">File</span>(<span class="hljs-string">&quot;local.properties&quot;</span>))<br><span class="hljs-keyword">def</span> flutterAar = localProperties.getProperty(<span class="hljs-string">&quot;flutterAar&quot;</span>, <span class="hljs-string">&quot;true&quot;</span>).toBoolean()<br><span class="hljs-keyword">if</span>(flutterAar)&#123;<br>api com.lxs.flutter:flutter:<span class="hljs-number">0.0</span>.<span class="hljs-number">8</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br>api <span class="hljs-keyword">project</span>(<span class="hljs-string">&#x27;:flutter&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="小优化"><a href="#小优化" class="headerlink" title="小优化"></a>小优化</h2><p>现在每次执行脚本都是所有插件都一股脑打aar、版本升级、上传，这显得非常耗时又没有意义。其实并不是每次所有插件module都需要做这部分操作的，插件内容没有更新的情况下完全没必要。我们可以用一个文件记录plugin和它都应的版本，然后和.flutter-plugins中的作比较，更新了的做打aar、升级、上传操作，没有更新的保持原版本（或者各个插件单独上传maven，根据.flutter-plugins做版本收拢）。git依赖是这种判断方式的软肋，需要做更深一步的检查（可能可以通过文件的摘要信息来对比）。</p><h2 id="更优的方案"><a href="#更优的方案" class="headerlink" title="更优的方案"></a>更优的方案</h2><p>github上有一种多module合并aar的方案 <a href="https://github.com/adwiv/android-fat-aar">https://github.com/adwiv/android-fat-aar</a> ，其实也是蛮适合flutter module打产物的——将plugin module的aar和flutter module的aar合并，但是由于没有想好module内部的三方依赖怎么合并，所以没有实施。实际上fat-aar可以将三方依赖也打进整个aar中，可能会造成gradle依赖冲突默认解决方式失效（默认是使用高版本的依赖）。不知道是不是可以通过合并pom文件解决，能想到的就这些，希望可以给各位提供一些思路。</p>]]></content>
    
    
    <categories>
      
      <category>flutter</category>
      
    </categories>
    
    
    <tags>
      
      <tag>flutter混合开发</tag>
      
      <tag>一键打aar</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>被React Native插件狂虐2天之后，写下c++_share.so冲突处理心路历程</title>
    <link href="/2021/07/07/c-so%E5%86%B2%E7%AA%81/"/>
    <url>/2021/07/07/c-so%E5%86%B2%E7%AA%81/</url>
    
    <content type="html"><![CDATA[<h3 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h3><p>为了应对活体检测客户react-native端的支持，需要开发react-native插件供客户使用。关于react-native插件开发具体可以参考react官网：</p><blockquote><p><a href="https://reactnative.cn/docs/native-modules-android">https://reactnative.cn/docs/native-modules-android</a><br><a href="https://reactnative.cn/docs/native-modules-ios">https://reactnative.cn/docs/native-modules-ios</a><br><a href="https://reactnative.cn/docs/native-components-android">https://reactnative.cn/docs/native-components-android</a><br><a href="https://reactnative.cn/docs/native-components-ios">https://reactnative.cn/docs/native-components-ios</a></p></blockquote><p>具体包含两部分</p><ol><li>ViewManager：包装原生的view供react-native的js部分使用</li><li>NativeModule：提供原生的api能力供react-native的js部分调用</li></ol><h3 id="心路历程"><a href="#心路历程" class="headerlink" title="心路历程"></a>心路历程</h3><p>参考着官方事例，插件代码很快就完成。开开心心把插件发布到github之后试用了一下就遇到了第一个问题</p><p><img src="/img/c++_1.png"></p><p>看错误很容易发现是so冲突了，也就是说react-native脚手架创建的项目原本就存在libc++_share.so，正好我们的活体检测sdk也存在libc++_shared.so。冲突的解决方法也很简单，在android域中添加如下配置：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">packagingOptions &#123;<br>    pickFirst &#x27;lib/arm64-v8a/libc++<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">_shared</span>.</span></span>so&#x27;<br>    pickFirst &#x27;lib/armeabi-v7a/libc++<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">_shared</span>.</span></span>so&#x27;<br>    pickFirst &#x27;lib/x86/libc++<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">_shared</span>.</span></span>so&#x27;<br>    pickFirst &#x27;lib/x86_64/libc++<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">_shared</span>.</span></span>so&#x27;<br>&#125;<br></code></pre></td></tr></table></figure><p>这边顺便解释下packagingOptions中几个关键字的意思和作用</p><table><thead><tr><th>关键字</th><th>含义</th><th>实例</th></tr></thead><tbody><tr><td>doNotStrip</td><td>可以设置某些动态库不被优化压缩</td><td>doNotStrip ‘*/arm64-v8a/libc++_shared.so’</td></tr><tr><td>pickFirst</td><td>匹配到多个相同文件，只提取第一个</td><td>pickFirst ‘lib/arm64-v8a/libc++_shared.so’</td></tr><tr><td>exclude</td><td>过滤掉某些文件或者目录不添加到APK中</td><td>exclude ‘lib/arm64-v8a/libc++_shared.so’</td></tr><tr><td>exclude</td><td>将匹配的文件合并添加到APK中</td><td>merge ‘lib/arm64-v8a/libc++_shared.so’</td></tr></tbody></table><p>上述例子中处理的方式是遇到冲突取第一个libc++_shared.so。冲突解决之后继续运行，打开摄像头过一会儿就崩溃了，报错如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::cout &lt;&lt; <span class="hljs-string">&quot;src: (&quot;</span> &lt;&lt; h &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; w &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; std::endl;<br></code></pre></td></tr></table></figure><p>仅仅是简单的c++输出流，对功能本来没有影响。很好奇为什么会崩溃，查了好久一无所获。既然不影响功能就先删掉了这行代码，果然就不报错了，功能都能正常使用了，开开心心的交给测试回归。一切都是好好的，直到跑在arm64-v8a的设备上，出现了如下报错：</p><p><img src="/img/c++_2.png"></p><p>这次有明显的报错信息，意思是当运行opencv_java3.so的时候缺少_sfp_handler_exception函数，这个函数实际上是在c++_shared.so库中的。奇怪的是原生代码运行在arm64-v8a的设备上是好的，那怎么跑在react-native环境就会缺少_sfp_handler_exception函数了呢？</p><p>直到我在原生用ndk20a编译代码报了同样的错误，才意识到一切问题的源头是pickFirst引起的。</p><p><img src="/img/c++_3.png"></p><p><img src="/img/c++_4.png"></p><p>可以明显的看到react-native和原生环境跑出来的apk包中c++_shared.so的大小是不同的。</p><p>也就是说pickFirst是存在安全隐患的，就拿这个例子来说，假如两个c++_shared.so是用不同版本的ndk打出来的，其实内部的库函数是不一样的，pickFirst贸然选择第一个必然导致另外的库不兼容。那么是不是可以用merge合并两个c++_shared.so，试了一下针对so merge失效了，只能是另辟蹊径。</p><p>如果我们的sdk只有一个库动态依赖于c++_shared.so，大可把c++_shared.so以静态库的方式打入，这样就不会有so冲突问题，同时也解决了上述问题。配置如下：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-class">externalNativeBuild </span>&#123;<br>    <span class="hljs-class">ndk </span>&#123;<br>        abiFilters <span class="hljs-string">&quot;armeabi-v7a&quot;</span>, <span class="hljs-string">&quot;arm64-v8a&quot;</span><br>    &#125;<br>    <span class="hljs-class">cmake </span>&#123;<br>        cppFlags <span class="hljs-string">&quot;-std=c++11 -frtti -fexceptions&quot;</span><br>        arguments <span class="hljs-string">&quot;-DANDROID_STL=c++_shared&quot;</span> <span class="hljs-comment">//shared改为static</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可惜的是例子中的sdk不止一个库动态依赖于c++_shared.so，所以这条路也行不通。那么只能从react-native侧出发寻找方案。</p><h4 id="方案一（推荐）"><a href="#方案一（推荐）" class="headerlink" title="方案一（推荐）"></a>方案一（推荐）</h4><p>找出react-native这边的c++_shared.so是基于什么ndk版本打出来的，想办法把两端的ndk版本保持统一，问题也就迎刃而解了。</p><p><img src="/img/c++_5.png"></p><p>从react-native对应的android工程的蛛丝马迹中发现大概是基于ndk r20b打出来的。接下来就是改造sdk中c++_shared.so基于的ndk版本了。</p><ol><li>基于ndk r20b版本重新编译opencv库</li><li>把opencv库连接到项目，基于ndk r20b版本重新编译alive_detected.so库</li></ol><p>把编译好的sdk重新导入插件升级，运行之后果然所有的问题得以解决。</p><h4 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h4><p>去除react-native中的c++_shared.so库，react-native并不是一开始就引入了c++_shared.so。从<a href="https://reactnative.cn/versions">React Native版本升级</a>中去查看c++_shared.so是哪个版本被引入的，可以发现0.59之前的版本是没有c++_shared.so库的，详见对比：</p><p><img src="/img/c++_6.png"></p><p><img src="/img/c++_7.png"></p><p>那么我们把react-native版本降级为0.59以下也能解决问题，降级步骤如下：</p><ol><li>进入工程</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> Temple<br></code></pre></td></tr></table></figure><ol start="2"><li>指定版本</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">npm</span> install --save react-native@<span class="hljs-number">0</span>.<span class="hljs-number">58</span>.<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><ol start="3"><li>更新</li></ol><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">react-<span class="hljs-keyword">native</span> upgrade<br></code></pre></td></tr></table></figure><ol start="4"><li>一路替换文件</li></ol><p><img src="/img/c++_8.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Android开发会面临各种环境问题，遇到问题还是要从原理出发，理清问题发生的根源，这样问题就很好解决。</p>]]></content>
    
    
    <categories>
      
      <category>React Native</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react-native</tag>
      
      <tag>so冲突</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sdk 打包必备，proguard 混淆规则如何配置</title>
    <link href="/2021/07/06/proguard%E8%A7%84%E5%88%99/"/>
    <url>/2021/07/06/proguard%E8%A7%84%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>作为一名 Android 开发者，如果你不想你的 app 或者 sdk 裸奔，那么在发布之前对代码混淆是必须的，它可以把类名、属性名和方法名变成毫无意义的 a,b,c 等。总得来说混淆带来两个好处：</p><ol><li>一定程度上减小包的体积</li><li>使代码反编译之后难以阅读</li></ol><p>混淆概念相对比较容易，很多 Android 开发者或多或少的都了解一些。那么对于混淆规则的配置有没有深入的研究呢？到底哪些代码应该混淆，哪些代码应该保留呢？很多时候是靠启动 CV 大法东拷贝一句西拷贝一句，搞到最后混淆规则配置文件杂乱无章。下面我就分享下 Android 中 ProGuard 那些事</p><h3 id="ProGuard-简介"><a href="#ProGuard-简介" class="headerlink" title="ProGuard 简介"></a>ProGuard 简介</h3><p>ProGuard 官网地址：<a href="https://www.guardsquare.com/proguard">https://www.guardsquare.com/proguard</a></p><p>ProGuard 的功能有四个：压缩、优化、混淆以及预校验；压缩环节会检测和移除无用的类、字段、方法和属性；优化环节会优化字节码和删除未使用的指令；混淆环节会用无意义的短变量去重命名类、字段以及方法；最后的预验证步骤向类添加预验证信息，这是 Java Micro Edition 和 Java 6 及更高版本所必需的，在 Android 开发中不需要。整个过程如下图所示：</p><p><img src="/img/proguard_1.png"></p><h3 id="Android-Studio-中启用-ProGuard"><a href="#Android-Studio-中启用-ProGuard" class="headerlink" title="Android Studio 中启用 ProGuard"></a>Android Studio 中启用 ProGuard</h3><p>Android Studio 集成 Java 语言的 ProGuard 作为压缩，优化和混淆工具，配合 Gradle 构建工具使用很简单，只需要在工程应用目录的 gradle 文件中设置 minifyEnabled 为 true 即可</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">buildTypes</span> &#123;<br>    <span class="hljs-section">release</span> &#123;<br>        <span class="hljs-attribute">minifyEnabled</span> <span class="hljs-literal">true</span><br>        proguardFiles getDefaultProguardFile(<span class="hljs-string">&#x27;proguard-android-optimize.txt&#x27;</span>), <span class="hljs-string">&#x27;proguard-rules.pro&#x27;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的配置表示对 release 版本进行混淆处理。proguardFiles 指定了配置混淆规则的文件，可以是多个文件，最后合并多个配置文件为一个</p><ul><li>getDefaultProguardFile(‘proguard-android-optimize.txt’) 方法从 Android SDK 安装目录的 tools/proguard/ 文件夹中获取默认的规则。默认只有压缩和混淆两个功能，想要进一步使用字节码优化功能请使用同一目录下的 proguard-android-optimize.txt 文件。</li></ul><p><font color=#FF8C00>注意：</font>从 Gradle 插件 2.2 版本开始，使用的是 Gradle 插件中内置的配置文件，可以在<project>/build/intermediates/proguard-files 下看到，Android SDK 目录下的配置文件会被插件忽略。</p><ul><li>proguard-rules.pro 用于添加自定义的混淆规则，例如保留一些不想被删除或混淆的代码。该文件默认位于 build.gradle 同级目录下。</li><li>一般还会配合 shrinkResources 来进行资源压缩，Android Studio 3.0 之后在 library 中不能配置 shrinkResources 否则报如下错误</li></ul><p><img src="/img/proguard_2.png"></p><p><strong>个人理解这个问题原因是 library 中的资源可能被外部引用，单独构建 library 的时无法确定资源是否应该删除</strong></p><h3 id="ProGuard-语法"><a href="#ProGuard-语法" class="headerlink" title="ProGuard 语法"></a>ProGuard 语法</h3><h4 id="ProGuard-语法的基本符号"><a href="#ProGuard-语法的基本符号" class="headerlink" title="ProGuard 语法的基本符号"></a>ProGuard 语法的基本符号</h4><p>- 表示一条规则的开始</p><h4 id="Keep-选项的语法"><a href="#Keep-选项的语法" class="headerlink" title="Keep 选项的语法"></a>Keep 选项的语法</h4><table><thead><tr><th>keep选项</th><th>描述</th><th>压缩</th><th>混淆</th></tr></thead><tbody><tr><td>-keep</td><td>保留指定的类和类成员，防止被移除或混淆</td><td>不压缩</td><td>不混淆</td></tr><tr><td>-keepnames</td><td>不混淆指定的类和类成员</td><td>压缩</td><td>不混淆</td></tr><tr><td>-keepclassmembers</td><td>保留指定类中的类成员，防止被移除或混淆。假如类未被保留则失效</td><td>不压缩</td><td>不混淆</td></tr><tr><td>-keepclassmembernames</td><td>不混淆指定类中的类成员</td><td>压缩</td><td>不混淆</td></tr><tr><td>-keepclasseswithmembers</td><td>保留类中成员及包含它的类，防止被移除或混淆</td><td>不压缩</td><td>不混淆</td></tr><tr><td>-keepclasseswithmembernames</td><td>不混淆类中成员及包含它的类</td><td>压缩</td><td>不混淆</td></tr></tbody></table><p>这三组看起来很容易混淆，其实掌握其中的关键就很好区分：</p><ol><li>带 name 后缀的表示只是防止混淆，若是没有被使用到还是可被移除；而没有带 name 后缀的表示防止被混淆和移除</li><li>-keep 表示保留指定的类和类成员，而 -keepclasseswithmembers 表示保留类中成员及包含它的类。例如：-keep class * {native <methods>;} 表示保留所有的类和其中的 native 方法；-keepclasseswithmembers class * {native <methods>;} 表示保留包含 native 方法的类和类中的 native 方法</li></ol><table><thead><tr><th>keep选项</th><th>描述</th><th>常用值</th><th>常用值说明</th></tr></thead><tbody><tr><td>-keeppackagenames</td><td>指定不混淆给定的包名称，接受逗号分隔的包名称列表</td><td>-keeppackagenames packagename1</td><td></td></tr><tr><td>-keepattributes</td><td>指定要保留的任何可选属性，接收逗号分隔的属性列表</td><td><em>Annotation</em>、SourceFile、InnerClasses、EnclosingMethod、Signature、LineNumberTable</td><td>注解、源文件的名称、内部类、定义类的方法、类、字段或方法的通用签名、方法的行号</td></tr><tr><td>-keepparameternames</td><td>指定保留参数名称和方法</td><td></td><td></td></tr></tbody></table><p>其他可选属性请看 <a href="https://www.guardsquare.com/manual/configuration/attributes">https://www.guardsquare.com/manual/configuration/attributes</a></p><h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><h5 id="类名"><a href="#类名" class="headerlink" title="类名"></a>类名</h5><table><thead><tr><th>通配符</th><th>含义</th></tr></thead><tbody><tr><td>?</td><td>匹配任意单个字符，包名分隔符(.)除外</td></tr><tr><td>*</td><td>匹配除(.)外的任意字符(不匹配子包)</td></tr><tr><td>**</td><td>匹配任意字符(匹配子包)</td></tr></tbody></table><h5 id="字段和方法"><a href="#字段和方法" class="headerlink" title="字段和方法"></a>字段和方法</h5><table><thead><tr><th>通配符</th><th>含义</th></tr></thead><tbody><tr><td>&lt;fields&gt;</td><td>匹配所有字段</td></tr><tr><td>&lt;methods&gt;</td><td>匹配所有方法，不包含构造方法</td></tr><tr><td><init>(…)</td><td>匹配所有构造方法</td></tr><tr><td>?</td><td>匹配任意单个字符</td></tr><tr><td>*</td><td>匹配除(.)外的任意字符，匹配任意字段和方法</td></tr></tbody></table><h5 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h5><table><thead><tr><th>通配符</th><th>含义</th></tr></thead><tbody><tr><td>%</td><td>匹配任意原始数据类型，例如 boolean、int，不包括 void</td></tr><tr><td>**</td><td>匹配任意字符，不匹配基础数据类型、数组、void</td></tr><tr><td>***</td><td>匹配任意类型</td></tr><tr><td>…</td><td>匹配任意参数个数，任意参数类型</td></tr></tbody></table><h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><table><thead><tr><th>修饰符</th><th>描述</th></tr></thead><tbody><tr><td>public</td><td>公共，通常和 class、 <fields>、<methods> 组合使用。例：public <methods></td></tr><tr><td>private</td><td>私有，通常和 class、<fields>、<methods> 组合使用。例：private <methods></td></tr><tr><td>protected</td><td>包内公共，通常和 class、 <fields>、<methods>  组合使用。例：protected <methods></td></tr><tr><td>native</td><td>本地，通常和 <methods> 组合使用保留本地方法。例：native <methods></td></tr><tr><td>extends</td><td>继承，通常和 class 配合使用。例： -keep class * extends android.app.Activity</td></tr><tr><td>implements</td><td>实现，通常和 class 配合使用。例：-keep class * implements android.view.OnClickListener</td></tr></tbody></table><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><table><thead><tr><th>符号</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td>includedescriptorclasses</td><td>不混淆方法和字段的类型描述符中的任何类，默认只保留基础数据类型</td><td>-keep, includedescriptorclasses</td></tr><tr><td>-dontwarn</td><td>不对未解析的引用和其他重要问题发出警告</td><td>-dontwarn twitter4j.**</td></tr><tr><td>-dontnote</td><td>不打印潜在的错误或疏漏的注释</td><td>-dontnote</td></tr><tr><td>-dontoptimize</td><td>关闭优化</td><td>-dontoptimize</td></tr><tr><td>-verbose</td><td>混淆过程中记录日志</td><td>-verbose</td></tr></tbody></table><p>更多配置请看proguard官网 <a href="https://www.guardsquare.com/manual/configuration/usage">https://www.guardsquare.com/manual/configuration/usage</a></p><h3 id="哪些类和类成员不应该被混淆"><a href="#哪些类和类成员不应该被混淆" class="headerlink" title="哪些类和类成员不应该被混淆"></a>哪些类和类成员不应该被混淆</h3><ol><li>需要暴露给外部调用的类和类成员(基本上是 public 方法和字段)</li><li>需要暴露给外部使用的内部类或者接口<br>保留内部类或者接口写下如下，内部类和外部类用 $ 衔接</li></ol><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stata">-<span class="hljs-keyword">keep</span> <span class="hljs-keyword">class</span> a<span class="hljs-variable">$b</span>&#123;<br><span class="hljs-comment">    *;</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>包名不混淆，否则很容易和其他库冲突<br>默认规则文件 proguard-android-optimize.txt 中的 -allowaccessmodification 配置会把混淆的类归到随机的包名下，如下图：</li></ol><p><img src="/img/proguard_3.png"></p><ol start="4"><li>依赖的三方库保留原始代码不动<br>不公开代码的三方库代码已经混淆过了，无需重复混淆。公开代码的三方库如果提供了混淆规则就复制过来，若是没有提供混淆规则不必大费周章的去找哪些代码不应该被压缩混淆，除非对包体积有很高的要求。</li></ol><p><strong>无需配置一堆规则的简介写法</strong></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-meta"># as3.0 之前的写法</span><br>-keep <span class="hljs-class"><span class="hljs-keyword">class</span> !<span class="hljs-title">packageName</span>.** </span>&#123;*;&#125;<br><span class="hljs-meta"># as3.0 之后的写法</span><br>-keep <span class="hljs-class"><span class="hljs-keyword">class</span> !<span class="hljs-title">packageName</span>.**,** </span>&#123;*;&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>在 AndroidManifest.xml 配置的四大组件<br>四大组件被混淆之后无法与 manifest 注册的类匹配</li><li>Java 的 native 方法<br>JNI 方法与定义的 native 方法名对应，混淆之后会找不到方法</li><li>反射使用的类、方法、属性<br>Class.forName(“”) 如类名被混淆将找不到类 </li><li>Json 对应的实体类<br>Gson 或者 Fastjson 的原理中涉及反射创建该类型的对象，反射需要用到完整类路径，混淆了会找不到</li><li>JavaScript 调用 Java 的方法</li><li>Layout 文件中使用到的自定义view 以及 set get 属性方法<br>Xml 配置的完整自定义 view 类路径，若自定义 view 混淆则找不到</li><li>在 Activity 中的方法参数是 view 的方法，即 layout 中定义的点击事件</li><li>Parcelable、Serializable 序列化类</li></ol><h3 id="默认规则"><a href="#默认规则" class="headerlink" title="默认规则"></a>默认规则</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-meta"># 不进行优化</span><br>-dontoptimize<br><span class="hljs-meta"># 不使用大小写混合类名</span><br>-dontusemixedcaseclassnames<br><span class="hljs-meta"># 指定不忽略非公共库类</span><br>-dontskipnonpubliclibraryclasses<br><span class="hljs-meta"># 混淆过程中记录日志</span><br>-verbose<br><span class="hljs-meta"># 保留注解属性、泛型、内部类、封闭方法，后面都是三个属性都是为了反射正常运行</span><br>-keepattributes *Annotation*,Signature,InnerClasses,EnclosingMethod<br><span class="hljs-meta"># 保留 google license 服务接口</span><br>-keep <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">com</span>.<span class="hljs-title">google</span>.<span class="hljs-title">vending</span>.<span class="hljs-title">licensing</span>.<span class="hljs-title">ILicensingService</span></span><br><span class="hljs-class">-<span class="hljs-title">keep</span> <span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">com</span>.<span class="hljs-title">android</span>.<span class="hljs-title">vending</span>.<span class="hljs-title">licensing</span>.<span class="hljs-title">ILicensingService</span></span><br><span class="hljs-class">-<span class="hljs-title">keep</span> <span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">com</span>.<span class="hljs-title">google</span>.<span class="hljs-title">android</span>.<span class="hljs-title">vending</span>.<span class="hljs-title">licensing</span>.<span class="hljs-title">ILicensingService</span></span><br><span class="hljs-class">-<span class="hljs-title">dontnote</span> <span class="hljs-title">com</span>.<span class="hljs-title">android</span>.<span class="hljs-title">vending</span>.<span class="hljs-title">licensing</span>.<span class="hljs-title">ILicensingService</span></span><br><span class="hljs-class">-<span class="hljs-title">dontnote</span> <span class="hljs-title">com</span>.<span class="hljs-title">google</span>.<span class="hljs-title">vending</span>.<span class="hljs-title">licensing</span>.<span class="hljs-title">ILicensingService</span></span><br><span class="hljs-class">-<span class="hljs-title">dontnote</span> <span class="hljs-title">com</span>.<span class="hljs-title">google</span>.<span class="hljs-title">android</span>.<span class="hljs-title">vending</span>.<span class="hljs-title">licensing</span>.<span class="hljs-title">ILicensingService</span></span><br><span class="hljs-class"># 不混淆包含 <span class="hljs-title">native</span> 方法的类和类中的 <span class="hljs-title">native</span> 方法以及方法的参数类型</span><br><span class="hljs-class">-<span class="hljs-title">keepclasseswithmembernames</span>,<span class="hljs-title">includedescriptorclasses</span> <span class="hljs-title">class</span> * </span>&#123;<br>    native &lt;methods&gt;;<br>&#125;<br><span class="hljs-meta"># 保留自定义 View 的 setXx() 和 getXx() 方法</span><br>-keepclassmembers <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> * <span class="hljs-keyword"><span class="hljs-keyword">extends</span> <span class="hljs-type">android</span></span>.<span class="hljs-title">view</span>.<span class="hljs-title">View</span> </span>&#123;<br>    void <span class="hljs-keyword">set</span>*(***);<br>    *** <span class="hljs-keyword">get</span>*();<br>&#125;<br><span class="hljs-meta"># 保留 Activity 中参数是 View 的方法</span><br>-keepclassmembers <span class="hljs-class"><span class="hljs-keyword">class</span> * <span class="hljs-keyword"><span class="hljs-keyword">extends</span> <span class="hljs-type">android</span></span>.<span class="hljs-title">app</span>.<span class="hljs-title">Activity</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> void *(android.view.View);<br>&#125;<br><span class="hljs-meta"># 保留 enum 中的静态 values() 和 valueOf 方法</span><br>-keepclassmembers <span class="hljs-class"><span class="hljs-keyword">enum</span> * &#123;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> **[] values();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ** valueOf(java.lang.<span class="hljs-keyword">String</span>);<br>&#125;<br><span class="hljs-meta"># 保留 Parcelable 子类中的 CREATOR 字段</span><br>-keepclassmembers <span class="hljs-class"><span class="hljs-keyword">class</span> * <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">android</span></span>.<span class="hljs-title">os</span>.<span class="hljs-title">Parcelable</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> final ** CREATOR;<br>&#125;<br><span class="hljs-meta"># 保留 JavascriptInterface 注解标记的方法</span><br>-keepclassmembers <span class="hljs-class"><span class="hljs-keyword">class</span> * </span>&#123;<br>    @android.webkit.JavascriptInterface &lt;methods&gt;;<br>&#125;<br><span class="hljs-meta"># 不对 android.support 包下的代码警告</span><br>-dontnote android.support.**<br>-dontnote androidx.**<br>-dontwarn android.support.**<br>-dontwarn androidx.**<br><br><span class="hljs-meta"># 不对 FloatMath 类代码警告</span><br>-dontwarn android.util.FloatMath<br><br><span class="hljs-meta"># 保留 Keep 注解标记的类型</span><br>-keep <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">android</span>.<span class="hljs-title">support</span>.<span class="hljs-title">annotation</span>.<span class="hljs-title">Keep</span></span><br><span class="hljs-class">-<span class="hljs-title">keep</span> <span class="hljs-title">class</span> <span class="hljs-title">androidx</span>.<span class="hljs-title">annotation</span>.<span class="hljs-title">Keep</span></span><br><span class="hljs-class"></span><br><span class="hljs-class">-<span class="hljs-title">keep</span> @<span class="hljs-title">android</span>.<span class="hljs-title">support</span>.<span class="hljs-title">annotation</span>.<span class="hljs-title">Keep</span> <span class="hljs-title">class</span> * </span>&#123;*;&#125;<br>-keep @androidx.annotation.Keep <span class="hljs-class"><span class="hljs-keyword">class</span> * </span>&#123;*;&#125;<br><br>-keepclasseswithmembers <span class="hljs-class"><span class="hljs-keyword">class</span> * </span>&#123;<br>    @android.support.annotation.Keep &lt;methods&gt;;<br>&#125;<br>-keepclasseswithmembers <span class="hljs-class"><span class="hljs-keyword">class</span> * </span>&#123;<br>    @androidx.annotation.Keep &lt;methods&gt;;<br>&#125;<br><span class="hljs-meta"># 标记字段时，保留标记的字段和包含它的类名</span><br>-keepclasseswithmembers <span class="hljs-class"><span class="hljs-keyword">class</span> * </span>&#123;<br>    @android.support.annotation.Keep &lt;fields&gt;;<br>&#125;<br>-keepclasseswithmembers <span class="hljs-class"><span class="hljs-keyword">class</span> * </span>&#123;<br>    @androidx.annotation.Keep &lt;fields&gt;;<br>&#125;<br><span class="hljs-meta"># 标记构造函数时，保留标记的构造函数和包含它的类名</span><br>-keepclasseswithmembers <span class="hljs-class"><span class="hljs-keyword">class</span> * </span>&#123;<br>    @android.support.annotation.Keep &lt;init&gt;(...);<br>&#125;<br>-keepclasseswithmembers <span class="hljs-class"><span class="hljs-keyword">class</span> * </span>&#123;<br>    @androidx.annotation.Keep &lt;init&gt;(...);<br>&#125;<br><span class="hljs-meta"># 不打印有关配置中潜在错误或遗漏的注释</span><br>-dontnote org.apache.http.**<br>-dontnote android.net.http.**<br><br><span class="hljs-meta"># 不打印有关配置中潜在错误或遗漏的注释</span><br>-dontnote java.lang.invoke.**<br></code></pre></td></tr></table></figure><h3 id="自定义规则配置模板"><a href="#自定义规则配置模板" class="headerlink" title="自定义规则配置模板"></a>自定义规则配置模板</h3><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs clean">#############################################<br># 写死部分<br>#############################################<br># 关闭预检<br>-dontpreverify<br># 保留参数名称和方法 IDE会提示形参<br>-keepparameternames<br># 抛出异常时保留行号，便于堆栈还原<br>-keepattributes SourceFile,LineNumberTable<br># 四大组件<br>-keep public <span class="hljs-keyword">class</span> * extends android.app.Activity <br>-keep public <span class="hljs-keyword">class</span> * extends android.app.Appliction <br>-keep public <span class="hljs-keyword">class</span> * extends android.app.Service <br>-keep public <span class="hljs-keyword">class</span> * extends android.content.BroadcastReceiver <br>-keep public <span class="hljs-keyword">class</span> * extends android.content.ContentProvider<br># layout 中使用的 Fragment<br>-keep public <span class="hljs-keyword">class</span> * extends android.support.v4.app.Fragment<br>-keep public <span class="hljs-keyword">class</span> * extends android.app.Fragment<br><br># 保留 R 下面的资源 <br>-keep <span class="hljs-keyword">class</span> **.R$* &#123;*;&#125;<br>-keepclassmembers <span class="hljs-keyword">class</span> **.R$* &#123;<br>    public static &lt;fields&gt;;<br>&#125;<br>#############################################<br># 自定义部分 需要修改<br>#############################################<br><br># 保留三方库<br>-keep <span class="hljs-keyword">class</span> !packageName.**,** &#123;*;&#125;<br># 保留包名<br>-keeppackagenames packageName<br># 保留与js交互的类和相应方法<br># 反射使用的类、方法、属性<br># Json 对应的实体类，建议放在统一包名下或者类加@Keep注解<br>-keep <span class="hljs-keyword">class</span> package.entity.*&#123;*;&#125;<br># layout 文件中使用到的自定义 View<br># 给外部调用的类和类成员<br># 给外部调用的内部类和接口<br></code></pre></td></tr></table></figure><h3 id="混淆后的堆栈还原"><a href="#混淆后的堆栈还原" class="headerlink" title="混淆后的堆栈还原"></a>混淆后的堆栈还原</h3><p>代码经过 Proguard 优化混淆之后增加了反编译的难度，同时也带来线上堆栈信息定位困难。好在 Proguard 为我们提供了还原工具，先来看下 Proguard 每次构建后生成的内容</p><h3 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h3><p>混淆构建完成之后，会在 <module-name>/build/outputs/mapping/release 目录下生成如下文件：</p><ul><li>configuration.txt<br>总的混淆规则配置文件，包含默认的和自定义的</li><li>mapping.txt<br>提供混淆前后的内容对照表</li><li>seeds.txt<br>罗列出未进行混淆处理的类和成员</li><li>usage.txt<br>罗列出被移除的代码</li></ul><h3 id="混淆还原"><a href="#混淆还原" class="headerlink" title="混淆还原"></a>混淆还原</h3><p>体统为我们提供了 retrace 工具来还原混淆，retrace 工具结合 mapping.txt 就可以将混淆后的堆栈信息还原为正常情况下的堆栈信息。主要有两种方式来还原：</p><ol><li>利用 retrace 脚本工具<br>脚本工具位于 Android Sdk 路径的 /tools/proguard/bin 目录中</li></ol><p><img src="/img/proguard_4.png"></p><p>Proguardgui.sh 是我们所需的脚本，将脚本拖到终端按回车就能看到如下 gui 界面</p><p><img src="/img/proguard_5.png"></p><p>选择 ReTrace 一栏。导入 mapping.txt 文件，然后在 stack trace 中填写混淆后的堆栈信息，最后点击 ReTrace 按钮就能还原我们的堆栈信息，从而快速定位线上问题</p><ol start="2"><li>利用 retrace 命令行<br>我们要先将崩溃信息保存到 txt 格式的文件中（如proguard.txt）保存，然后执行如下命令:</li></ol><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">retrace.sh -<span class="hljs-keyword">verbose</span> <span class="hljs-keyword">mapping</span>.txt proguard.txt<br></code></pre></td></tr></table></figure><p>通过上述堆栈还原的分析可以发现最重要的是 mapping.txt 文件，里面记录了混淆前后的内容对照。如果 mapping.txt 文件丢失，堆栈将无法还原。<font color=#FF8C00>所以每个版本的 mapping.txt 文件一定要保存好</font>，最好有一个版本追溯（可以存在打包机上）</p><h3 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h3><p>在 module 库中配置 consumerProguardFiles 可以将混淆规则一并打入库产物 aar 中，这样使用方使用我们的库将无需额外配置库对应的混淆规则</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">defaultConfig &#123;<br>    minSdkVersion 16<br>    targetSdkVersion 30<br>    <span class="hljs-keyword">version</span>Code 1<br>    <span class="hljs-keyword">version</span>Name <span class="hljs-string">&quot;1.0&quot;</span><br>    <br>    consumerProguardFiles <span class="hljs-string">&quot;consumer-rules.pro&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/proguard_6.png"></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sdk</tag>
      
      <tag>proguard</tag>
      
      <tag>混淆</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
